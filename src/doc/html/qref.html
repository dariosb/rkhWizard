<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RKH: Quick reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">RKH
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Quick reference </div>  </div>
</div>
<div class="contents">
<div class="textblock"><div class="image">
<img src="rkh_bunner.jpg" alt="rkh_bunner.jpg"/>
</div>
<p>Prev: <a class="el" href="index.html#main_page">Home</a> <br/>
 Next: <a class="el" href="_installation.html">Installation</a></p>
<p>The main objective of this section is to show and also illustrate the most important concepts to apply when dealing with RKH and the event-driven applications.</p>
<p>This section includes:</p>
<ul>
<li><a class="el" href="qref.html#qref0">Defining a state machine</a></li>
<li><a class="el" href="qref.html#qref1">Defining a composite state</a></li>
<li><a class="el" href="qref.html#qref2">Defining a basic state</a></li>
<li><a class="el" href="qref.html#qrefsb">Defining a submachine state</a></li>
<li><a class="el" href="qref.html#qref16">Defining a state transition table</a></li>
<li><a class="el" href="qref.html#qref3">Defining a conditional pseudostate</a></li>
<li><a class="el" href="qref.html#qref17">Defining a branch table</a></li>
<li><a class="el" href="qref.html#qref4">Defining a shallow history pseudostate</a></li>
<li><a class="el" href="qref.html#qref5">Defining a deep history pseudostate</a></li>
<li><a class="el" href="qref.html#qref6">Defining a junction pseudostate</a></li>
<li><a class="el" href="qref.html#qref14">Defining entry, exit, and transition actions</a></li>
<li><a class="el" href="qref.html#qref12">Using events with parameters</a></li>
<li><a class="el" href="qref.html#qref7">Using dynamic and static events</a></li>
<li><a class="el" href="qref.html#qref13">Preprocessing events before of dispatch it</a></li>
<li><a class="el" href="qref.html#qref8">Deferring and recalling events</a></li>
<li><a class="el" href="qref.html#qref9">Using assertions</a></li>
<li><a class="el" href="qref.html#qref10">Debugging an application based on RKH's state machines</a></li>
<li><a class="el" href="qref.html#qref15">Initializing a state machine and dispatching events</a></li>
<li><a class="el" href="qref.html#qref18">Using RKH software timers</a></li>
</ul>
<p><br/>
 <hr/>
 <h2><a class="anchor" id="qref0"></a>
Defining a state machine</h2>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a> <br/>
</p>
<p>A state machine application is defined with the <a class="el" href="rkh_8h.html#ae6c326c33b1cc4acf2529c628ba8c2aa" title="Declare and allocate a SMA (active object) derived from RKHSMA_T. Also, initializes and assigns a sta...">RKH_SMA_CREATE()</a> macro and declared with the <a class="el" href="rkh_8h.html#aab4c88b9429479d470bde8e05b2feead" title="This macro declares a opaque pointer to previously created state machine application (SMA) to be used...">RKH_SMA_DCLR()</a> macro. Frequently, each state machine is encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#ae6c326c33b1cc4acf2529c628ba8c2aa" title="Declare and allocate a SMA (active object) derived from RKHSMA_T. Also, initializes and assigns a sta...">RKH_SMA_CREATE()</a> macro is used, thus the structure definition is in fact entirely encapsulated in its module and is inaccessible to the rest of the application. However, as a general rule, the state machine application must be declared inside a header file (.h file) by means of <a class="el" href="rkh_8h.html#aab4c88b9429479d470bde8e05b2feead" title="This macro declares a opaque pointer to previously created state machine application (SMA) to be used...">RKH_SMA_DCLR()</a> macro. We will develop one example of state machine creation to illustrate the use of this macro. Also, we will give our hierarchical state machine the name <code>my</code>. If you wanted to create a "flat" state machine, you would use the <a class="el" href="rkh_8h.html#a243967727eeb1814b24badfeda7b25b7a0338024d4d0d5bffed604c279f8f5550">FLAT</a> parameter rather than the <a class="el" href="rkh_8h.html#a243967727eeb1814b24badfeda7b25b7af9de2b2b683900d16cf6a78acb458eda">HCAL</a> parameter.</p>
<p>This section includes:</p>
<ul>
<li><a class="el" href="qref.html#qref0_1">Defining the state machine application</a></li>
<li><a class="el" href="qref.html#qref0_2">Declaring the state machine</a></li>
<li><a class="el" href="qref.html#qref0_3">Customization</a></li>
</ul>
<h3><a class="anchor" id="qref0_1"></a>
Defining the state machine application</h3>
<p><br/>
 </p>
<div class="fragment"><pre class="fragment">(1) <span class="comment">//  my.c: state machine application&#39;s module</span>

(2) <span class="keyword">typedef</span> <span class="keyword">struct</span>
    {
        <a class="code" href="struct_r_k_h_s_m_a___t.html" title="Describes the SMA (active object in UML).">RKHSMA_T</a> sm;    <span class="comment">// base structure</span>
        rkhui8_t x;     <span class="comment">// private member</span>
        rkhui8_t y;     <span class="comment">// private member</span>
    } MYSM_T;

(3) <span class="keyword">static</span> <a class="code" href="rkh_8h.html#ac2d1fc13a6b019e7967db720d72dfcd8" title="This macro declares and initializes the event structure e with es signal and establishes it as one st...">RKH_DCLR_STATIC_EVENT</a>( turnon, TURNON );

(4) <a class="code" href="rkh_8h.html#ae6c326c33b1cc4acf2529c628ba8c2aa" title="Declare and allocate a SMA (active object) derived from RKHSMA_T. Also, initializes and assigns a sta...">RKH_SMA_CREATE</a>(     MYSM_T,     <span class="comment">// state machine application data type</span>
(5)                     3,          <span class="comment">// ID</span>
(6)                     my,         <span class="comment">// name</span>
(7)                     2,          <span class="comment">// priority number</span>
(8)                     <a class="code" href="rkh_8h.html#a243967727eeb1814b24badfeda7b25b7af9de2b2b683900d16cf6a78acb458eda">HCAL</a>,       <span class="comment">// hierarchical state machine</span>
(9)                     &amp;S1,        <span class="comment">// initial state</span>
(10)                    my_init,    <span class="comment">// initial action</span>
(11)                    &amp;turnon );  <span class="comment">// initial event</span>
</pre></div><h3><a class="anchor" id="qref0_2"></a>
Declaring the state machine</h3>
<div class="fragment"><pre class="fragment"><span class="comment">//  my.h: state-machine application&#39;s header file</span>

<a class="code" href="rkh_8h.html#aab4c88b9429479d470bde8e05b2feead" title="This macro declares a opaque pointer to previously created state machine application (SMA) to be used...">RKH_SMA_DCLR</a>( my );
</pre></div><p>Explanation</p>
<ul>
<li>(1) Frequently, each state machine application is encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#ae6c326c33b1cc4acf2529c628ba8c2aa" title="Declare and allocate a SMA (active object) derived from RKHSMA_T. Also, initializes and assigns a sta...">RKH_SMA_CREATE()</a> macro is used. </li>
<li>(2) The MYSM_T defines the <code>my</code> state machine application structure. Almost every state machine applications must also store other "extended-state" information. You supply this additional information by means of data members enlisted after the base structure member <code>sm</code>. This illustrates how to derive an state machine application from <a class="el" href="struct_r_k_h_s_m_a___t.html" title="Describes the SMA (active object in UML).">RKHSMA_T</a>. Please note that the <a class="el" href="struct_r_k_h_s_m_a___t.html" title="Describes the SMA (active object in UML).">RKHSMA_T</a> member <code>sm</code> is defined as the FIRST member of the derived struct. <a class="el" href="struct_r_k_h_s_m_a___t.html" title="Describes the SMA (active object in UML).">RKHSMA_T</a> is not intended to be instantiated directly, but rather serves as the base structure for derivation of state machines in the application code. </li>
<li>(3) Declares and initializes the event structure <code>turnon</code> with <code>TURNON</code> signal and establishes it as one static event. The created event object is explicitly placed in ROM.. </li>
<li>(4) As said below, the MYSM_T defines the <code>my</code> state machine application structure. </li>
<li>(5) <code>3</code> is the state machine application ID. This number allows to uniquely identify a state machine application. </li>
<li>(6) <code>my</code> is the state machine application. Represents the top state of state diagram. </li>
<li>(7) <code>2</code> is the state machine application priority. </li>
<li>(8) the <code>my</code> state machine is defined as a hierarchical state machine. The available property options are enumerated in RKH_HPPTY_T enumeration in the <b><a class="el" href="rkh_8h.html" title="RKH platform-independent interface.">rkh.h</a></b> file. </li>
<li>(9) <code>S1</code> is the initial state. </li>
<li>(10) <code>my_init()</code> function defines the topmost initial transition in the <code>my</code> state machine. The function prototype is defined as RKHINIT_T. This argument is (optional), thus it could be declared as NULL. The application code must trigger the initial transition explicitly by invoking <a class="el" href="rkh_8h.html#a02d78c8f4c9f8e2b9fb0cf57711c1220" title="Initializes and activates a previously created state machine application.">rkh_sma_activate()</a> function. </li>
<li>(11) <code>turnon</code> is a pointer to an event that will be passed to state machine application when it starts. Could be used to pass arguments to the state machine like an argc/argv. This argument is optional, thus it could be declared as NULL or eliminated in compile-time with RKH_SMA_EN_IEVENT = 0.</li>
</ul>
<h3><a class="anchor" id="qref0_3"></a>
Customization</h3>
<p>Each RKH application must have its own configuration file, called <b><a class="el" href="rkhcfg_8h.html" title="RKH user configuration.">rkhcfg.h</a></b>. This file adapts and configures RKH by means of compiler definitions and macros allowing to restrict the resources consumed by RKH. Adjusting this definitions allows to reduce the ROM and RAM consumption, and to enhance the system performance in a substantial manner. The <b><a class="el" href="rkhcfg_8h.html" title="RKH user configuration.">rkhcfg.h</a></b> shows the general layout of the configuration file.</p>
<p>Use the following macros to reduce the memory taken by state machine structure. See <a class="el" href="cfg.html">Configuration</a> section for more information.</p>
<ul>
<li><b>RKH_SMA_EN_IEVENT:</b> <br/>
 When RKH_SMA_EN_IEVENT is set to one (1) the <a class="el" href="struct_r_k_h_s_m_a___t.html" title="Describes the SMA (active object in UML).">RKHSMA_T</a> structure allows to reference a event, which will be passed to state machine application when it starts. Could be used to pass arguments to the state machine like an argc/argv. <br/>
<br/>
</li>
<li><b>RKH_SMA_EN_ID:</b> <br/>
 When RKH_SMA_EN_ID is set to one (1) the <a class="el" href="struct_r_k_h_s_m_a___t.html" title="Describes the SMA (active object in UML).">RKHSMA_T</a> structure includes a ID number that could be used to uniquely identify a state machine application.</li>
</ul>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<hr/>
 <h2><a class="anchor" id="qref1"></a>
Defining a composite state</h2>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<p>A superstate or composite state is defined with the <a class="el" href="rkh_8h.html#acc24b2221cd374e66732a09fb24b56ce" title="This macro creates a composite state.">RKH_CREATE_COMP_STATE()</a> macro and declared with the <a class="el" href="rkh_8h.html#ab856423b3e65be3f55b7df3b2984e5fe" title="Declares a previously created state/pseudostate to be used as a global object.">RKH_DCLR_COMP_STATE</a> macro. Frequently, each state machine and its states (composite and basic) are encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#acc24b2221cd374e66732a09fb24b56ce" title="This macro creates a composite state.">RKH_CREATE_COMP_STATE()</a> macro is used. We will develop one example of composite state definition to illustrate the use of this macro. We will give our composite state the name <code>S1</code>.</p>
<p>This section includes:</p>
<ul>
<li><a class="el" href="qref.html#qref1_1">Defining a composite state</a></li>
<li><a class="el" href="qref.html#qref1_2">Declaring a composite state</a></li>
<li><a class="el" href="qref.html#qref1_3">Customization</a></li>
</ul>
<h3><a class="anchor" id="qref1_1"></a>
Defining a composite state</h3>
<div class="fragment"><pre class="fragment">(1) <span class="comment">//  my.c: state-machine&#39;s module</span>

(2) <a class="code" href="rkh_8h.html#acc24b2221cd374e66732a09fb24b56ce" title="This macro creates a composite state.">RKH_CREATE_COMP_STATE</a>(  S1, 
(3)                         0, 
(4)                         turn_on, 
(5)                         turn_off, 
(6)                         &amp;SA, 
(7)                         &amp;S11, 
(8)                         &amp;H );
</pre></div><h3><a class="anchor" id="qref1_2"></a>
Declaring a composite state</h3>
<div class="fragment"><pre class="fragment"><span class="comment">//  my.h: state-machine&#39;s header file</span>

...
RKH_DCLR_COMP_STATE S1;
</pre></div><p>Explanation</p>
<ul>
<li>(1) Frequently, each state machine and its states are encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#acc24b2221cd374e66732a09fb24b56ce" title="This macro creates a composite state.">RKH_CREATE_COMP_STATE()</a> macro is used. </li>
<li>(2) <code>S1</code> is the state name. Represents a composite state structure. </li>
<li>(3) <code>0</code> is the value of state ID. </li>
<li>(4) <code>turn_on()</code> defines the entry action to be executed unconditionally upon the entry to the <code>S1</code> state. This argument is optional, thus it could be declared as NULL. The RKHENT_T defines the function prototype. </li>
<li>(5) <code>turn_off()</code> defines the exit action, which is executed upon exit from the <code>S1</code> state. This argument is optional, thus it could be declared as NULL. The RKHEXT_T defines the function prototype. </li>
<li>(6) <code>SA</code> is the parent state of <code>S1</code>. If a state has no explicit superstate means that it is implicitly nested in the "top" state, and the parent state is defined by means of RKH_ROOT macro. The "top" state is a UML concept that denotes the ultimate root of the state hierarchy in a hierarchical state machine. </li>
<li>(7) <code>S11</code> is the default state of <code>S1</code> state machine. At each level of nesting, a superstate can have a private initial transition that designates the active substate after the superstate is entered directly. Here the initial transition of state <code>S1</code> designates the state <code>S11</code> as the initial active substate. </li>
<li>(8) <code>H</code> is the history pseudostate. This argument is optional, thus it could be declared as NULL. See <a class="el" href="rkh_8h.html#a7a5376dd9929642f5b6e31def6d92bb4" title="This macro creates a shallow history pseudostate.">RKH_CREATE_SHALLOW_HISTORY_STATE()</a> macro and <a class="el" href="rkh_8h.html#a49995aa34cddd68fcc6416655ca408f8" title="This macro creates a deep history pseudostate.">RKH_CREATE_DEEP_HISTORY_STATE()</a>.</li>
</ul>
<h3><a class="anchor" id="qref1_3"></a>
Customization</h3>
<p>Each RKH application must have its own configuration file, called <b><a class="el" href="rkhcfg_8h.html" title="RKH user configuration.">rkhcfg.h</a></b>. This file adapts and configures RKH by means of compiler definitions and macros allowing to restrict the resources consumed by RKH. Adjusting this definitions allows to reduce the ROM and RAM consumption, and to enhance the system performance in a substantial manner. The <b><a class="el" href="rkhcfg_8h.html" title="RKH user configuration.">rkhcfg.h</a></b> shows the general layout of the configuration file.</p>
<p>Use the following macros to reduce the memory taken by state machine structure. See <a class="el" href="cfg.html">Configuration</a> section for more information.</p>
<ul>
<li><b>RKH_SMA_EN_HCAL:</b> <br/>
 Enable (1) or disable (0) the state nesting. When RKH_SMA_EN_HCAL is set to one (1) some important features of RKH are not included: state composite state, history (shallow and deep) pseudostate, entry action, and exit action. <br/>
<br/>
</li>
<li><b>RKH_SMA_EN_STATE_ID:</b> <br/>
 When RKH_SMA_EN_STATE_ID is set to one (1) the state structure includes an ID number. This number allows to uniquely identify a state.</li>
</ul>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<hr/>
 <h2><a class="anchor" id="qref2"></a>
Defining a basic state</h2>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<p>A basic state (also called substate) is defined with the <a class="el" href="rkh_8h.html#a3567a7f91a5dc5759747dc8528357b44" title="This macro creates a basic state.">RKH_CREATE_BASIC_STATE()</a> macro and declared with the <a class="el" href="rkh_8h.html#a483ad8fd1a11d5b823e58a2884e40f22" title="Declares a previously created state/pseudostate to be used as a global object.">RKH_DCLR_BASIC_STATE</a> macro. Frequently, each state machine and its states (composite and basic) are encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#a3567a7f91a5dc5759747dc8528357b44" title="This macro creates a basic state.">RKH_CREATE_BASIC_STATE()</a> macro is used. We will develop one example of basic state definition to illustrate the use of this macro. We will give our basic state the name <code>S11</code>. As will demostrates the use of <a class="el" href="rkh_8h.html#a3567a7f91a5dc5759747dc8528357b44" title="This macro creates a basic state.">RKH_CREATE_BASIC_STATE()</a> macro and its arguments is very similar to <a class="el" href="rkh_8h.html#acc24b2221cd374e66732a09fb24b56ce" title="This macro creates a composite state.">RKH_CREATE_COMP_STATE()</a> macro.</p>
<p><b>Defining a basic state</b> </p>
<div class="fragment"><pre class="fragment">(1) <span class="comment">//  my.c: state-machine&#39;s module</span>

(2) <a class="code" href="rkh_8h.html#a3567a7f91a5dc5759747dc8528357b44" title="This macro creates a basic state.">RKH_CREATE_BASIC_STATE</a>( S11, 
(3)                         4, 
(4)                         start_process, 
(5)                         stop_process, 
(6)                         &amp;S1, 
(7)                         in_keyb );
</pre></div><p><b>Declaring a basic state</b> </p>
<div class="fragment"><pre class="fragment"><span class="comment">//  my.h: state-machine&#39;s header file</span>

...
RKH_DCLR_BASIC_STATE S11;
</pre></div><p>Explanation</p>
<ul>
<li>(1) Frequently, each state machine and its states are encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#a3567a7f91a5dc5759747dc8528357b44" title="This macro creates a basic state.">RKH_CREATE_BASIC_STATE()</a> macro is used. </li>
<li>(2) <code>S11</code> is the state name. Represents a substate structure. </li>
<li>(3) <code>4</code> is the value of state ID. </li>
<li>(4) <code>start_process()</code> defines the entry action to be executed unconditionally upon the entry to the <code>S11</code> state. This argument is optional, thus it could be declared as NULL. The RKHENT_T defines the function prototype. </li>
<li>(5) <code>stop_process()</code> defines the exit action, which is executed upon exit from the <code>S11</code> state. This argument is optional, thus it could be declared as NULL. The RKHEXT_T defines the function prototype. </li>
<li>(6) <code>S1</code> is the parent state of <code>S11</code>. If a state has no explicit superstate means that it is implicitly nested in the "top" state, and the parent state is defined by means of RKH_ROOT macro. The "top" state is a UML concept that denotes the ultimate root of the state hierarchy in a hierarchical state machine. </li>
<li>(7) <code>in_keyb()</code> defines the event preprocessor action. Before sending the arrived event to state machine, it can be previously processed using the event preprocessor function. An action function takes the state machine pointer and the event pointer as arguments. The first parameter is optional in compile-time according to <b>RKH_EN_PPRO_HSM_ARG</b> macro. Example: <div class="fragment"><pre class="fragment"><span class="keyword">static</span>
<a class="code" href="rkhevt_8h.html#a8a78cec3a9dfc2336bd084c221e15e10">RKHE_T</a>
in_keyb( <a class="code" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> *pe )
{
    <span class="keywordflow">if</span>( pe-&gt;<a class="code" href="struct_r_k_h_e_v_t___t.html#ace79af9a2276cf72d7accf7f8f2c957e">e</a> &gt;= 0 &amp;&amp; pe-&gt;<a class="code" href="struct_r_k_h_e_v_t___t.html#ace79af9a2276cf72d7accf7f8f2c957e">e</a> &lt;= 9 )
        <span class="keywordflow">return</span> DECIMAL;
    <span class="keywordflow">if</span>( pe-&gt;<a class="code" href="struct_r_k_h_e_v_t___t.html#ace79af9a2276cf72d7accf7f8f2c957e">e</a> == <span class="charliteral">&#39;.&#39;</span> )
        <span class="keywordflow">return</span> POINT;
    <span class="keywordflow">else</span>
        <span class="keywordflow">return</span> pe-&gt;<a class="code" href="struct_r_k_h_e_v_t___t.html#ace79af9a2276cf72d7accf7f8f2c957e">e</a>;
}
</pre></div></li>
</ul>
<ul>
<li>(7) Aditionally, by means of single inheritance in C it could be used to supply additional information to state. Implementing the single inheritance in C is very simply by literally embedding the base type, RKHPPRO_T in this case, as the first member of the derived structure. This argument is optional, thus it could be declared as NULL. Example: <div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">struct</span>
{
    <a class="code" href="rkhitl_8h.html#a3f1afca9ba9935082740bf026862729c" title="Event preprocessor.">RKHPPRO_T</a> prepro;   <span class="comment">// extend the RKHPPRO_T class</span>
    <span class="keywordtype">unsigned</span> min:4;     <span class="comment">// addtional information...</span>
    <span class="keywordtype">unsigned</span> max:4;
    <span class="keywordtype">char</span> *buff;
} SDATA_T;              <span class="comment">// this data type will be used in S12 context</span>

<span class="keyword">static</span> <span class="keyword">const</span> SDATA_T option = { preprocessor, 4, 8, token };

<span class="comment">/* Define S11 state as a substate of S1 */</span>
<a class="code" href="rkh_8h.html#a3567a7f91a5dc5759747dc8528357b44" title="This macro creates a basic state.">RKH_CREATE_BASIC_STATE</a>( S11, 4, start_process, start_process, &amp;S1, in_keyb ); 

<span class="comment">/* Define S12 state as a substate of S1 */</span>
<a class="code" href="rkh_8h.html#a3567a7f91a5dc5759747dc8528357b44" title="This macro creates a basic state.">RKH_CREATE_BASIC_STATE</a>( S12, 5, NULL, NULL, &amp;S1, (<a class="code" href="rkhitl_8h.html#a3f1afca9ba9935082740bf026862729c" title="Event preprocessor.">RKHPPRO_T</a>*)&amp;option ); 
</pre></div></li>
</ul>
<p><b>Customization</b> </p>
<p>Each RKH application must have its own configuration file, called <b><a class="el" href="rkhcfg_8h.html" title="RKH user configuration.">rkhcfg.h</a></b>. This file adapts and configures RKH by means of compiler definitions and macros allowing to restrict the resources consumed by RKH. Adjusting this definitions allows to reduce the ROM and RAM consumption, and to enhance the system performance in a substantial manner. The <b><a class="el" href="rkhcfg_8h.html" title="RKH user configuration.">rkhcfg.h</a></b> shows the general layout of the configuration file.</p>
<p>Use the following macros to reduce the memory taken by state machine structure. See <a class="el" href="cfg.html">Configuration</a> section for more information.</p>
<ul>
<li><b>RKH_SMA_EN_STATE_ID:</b> <br/>
 When RKH_SMA_EN_STATE_ID is set to one (1) the state structure includes an ID number. This number allows to uniquely identify a state. <br/>
<br/>
</li>
<li><b>RKH_SMA_EN_PPRO:</b> <br/>
 When RKH_SMA_EN_PPRO is set to one (1) the state structure includes an reference to preprocessor function. This function could be called "Moore" action. This argument is optional, thus it could be declared as NULL. Aditionally, by means of single inheritance in C it could be used as state's abstract data. Aditionally, implementing the single inheritance in C is very simply by literally embedding the base type, RKHPPRO_T in this case, as the first member of the derived structure. See <em>prepro</em> member of RKHSREG_T structure for more information.</li>
</ul>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<hr/>
 <h2><a class="anchor" id="qrefsb"></a>
Defining a submachine state</h2>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<p>A submachine state is a kind of a state that actually refers to another defined state machine. The diagram in following figure shows a fragment from a state machine diagram in which a submachine state (the <code>SB</code>) is referenced.</p>
<p><a class="anchor" id="fig_sbm1"></a></p>
<div class="image">
<img src="sbm1.png" alt="sbm1.png"/>
<div class="caption">
Submachine state</div></div>
<p> In the above example, the transition triggered by event <code>TWO</code> will terminate on entry point <code>ENS12</code> of the <code>SB</code> state machine. The <code>ONE</code> transition implies taking of the default transition of the <code>SB</code> and executes the <code>act5()</code> action. The transition emanating from the <code>EX1S12</code> exit point of the submachine will execute the <code>act1()</code> behavior in addition to what is executed within the <code>SB</code> state machine. Idem transition emanating from the <code>EX2S12</code>. This transition must have been triggered within the <code>SB</code> state machine. Finally, the transition emanating from the edge of the submachine state is triggered by event <code>THREE</code>.</p>
<p>The following figure is an example of a state machine <code>SB</code> defined with two exit points, <code>EXPNT1</code> and <code>EXPNT2</code>, and one entry point <code>ENPNT</code>.</p>
<p><a class="anchor" id="fig_sbm2"></a></p>
<div class="image">
<img src="sbm2.png" alt="sbm2.png"/>
<div class="caption">
State machine with two exit points and one entry point</div></div>
<p> In the following figure the state machine shown above is referenced twice in a submachine state <code>S12</code> and <code>S2</code>.</p>
<p><a class="anchor" id="fig_sbm3"></a></p>
<div class="image">
<img src="sbm3.png" alt="sbm3.png"/>
<div class="caption">
Submachine state with usage of exit and entry points</div></div>
<p> This section includes:</p>
<ul>
<li><a class="el" href="qref.html#qrefsb_1">Defining a submachine state</a></li>
<li><a class="el" href="qref.html#qrefsb_2">Declaring a submachine state</a></li>
<li><a class="el" href="qref.html#qrefsb_3">Defining the exit connection references</a></li>
<li><a class="el" href="qref.html#qrefsb_4">Defining the entry connection references</a></li>
<li><a class="el" href="qref.html#qrefsb_5">Declaring entry connection references</a></li>
<li><a class="el" href="qref.html#qrefsb_6">Defining a submachine</a></li>
<li><a class="el" href="qref.html#qrefsb_7">Declaring a submachine</a></li>
<li><a class="el" href="qref.html#qrefsb_8">Defining the exit point</a></li>
<li><a class="el" href="qref.html#qrefsb_9">Declaring a submachine</a></li>
<li><a class="el" href="qref.html#qrefsb_10">Defining the entry point</a></li>
<li><a class="el" href="qref.html#qrefsb_11">Declaring a entry point</a></li>
<li><a class="el" href="qref.html#qrefsb_c">Customization</a></li>
</ul>
<h3><a class="anchor" id="qrefsb_1"></a>
Defining a submachine state</h3>
<p>A submachine state is defined with the <a class="el" href="rkh_8h.html#a5a859233f4fab22d4b321c6ac122d382" title="This macro creates a submachine state.">RKH_CREATE_SUBMACHINE_STATE()</a> macro and declared with the <a class="el" href="rkh_8h.html#a956285310d9b0cd90c5c9280b197f9fd" title="Declares a previously created state/pseudostate to be used as a global object.">RKH_DCLR_SUBM_STATE</a> macro. Frequently, each state machine and its states (composites, basic, and submachine states) are encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#a5a859233f4fab22d4b321c6ac122d382" title="This macro creates a submachine state.">RKH_CREATE_SUBMACHINE_STATE()</a> macro is used. We will develop one example of submachine state definition to illustrate the usage and its related macros. We will give our submachine state the name <code>S12</code>.</p>
<div class="fragment"><pre class="fragment">(1) <span class="comment">//  my.c: state-machine&#39;s module</span>

(2) <a class="code" href="rkh_8h.html#a5a859233f4fab22d4b321c6ac122d382" title="This macro creates a submachine state.">RKH_CREATE_SUBMACHINE_STATE</a>(    S12, 
(3)                                 7, 
(4)                                 NULL, 
(5)                                 NULL, 
(6)                                 &amp;S1, 
(7)                                 &amp;SB );
</pre></div><p>Explanation</p>
<ul>
<li>(1) Frequently, each state machine and its states are encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#a5a859233f4fab22d4b321c6ac122d382" title="This macro creates a submachine state.">RKH_CREATE_SUBMACHINE_STATE()</a> macro is used. </li>
<li>(2) <code>S12</code> is the state name. Represents a submachine state structure. </li>
<li>(3) <code>7</code> is the value of state ID. </li>
<li>(4) the entry action is not used. </li>
<li>(5) the exit action is not used. </li>
<li>(6) <code>S1</code> is the parent state of <code>S12</code>. If a state has no explicit superstate means that it is implicitly nested in the "top" state, and the parent state is defined by means of RKH_ROOT macro. The "top" state is a UML concept that denotes the ultimate root of the state hierarchy in a hierarchical state machine. </li>
<li>(7) <code>SB</code> is the defined submachine state machine, which is referenced by <code>S12</code> submachine state.</li>
</ul>
<p>On the other hand, in RKH every submachine state is associated with a transition table, which is composed of a well-defined set of transitions. See <a class="el" href="qref.html#qref16">Defining a state transition table</a> for defining a state transition table.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="rkh_8h.html#aef55bd044383009972f38c332f8210a9" title="This macro creates a state transition table. This table have the general structure shown below:...">RKH_CREATE_TRANS_TABLE</a>( S12 )
    <a class="code" href="rkh_8h.html#ac257d157f98ef172e5e8c8725a293bdf" title="This macro defines an internal state transition. Internal transitions are simple reactions to events ...">RKH_TRINT</a>( TERM,    NULL,   terminate ),
    <a class="code" href="rkh_8h.html#ab0fc2ccb4b73d57ea0c0f478353a00f6" title="This macro defines a regular state transition. The general syntax of an expression labelling a transi...">RKH_TRREG</a>( THREE,   NULL,   NULL,   &amp;S1 ),
<a class="code" href="rkh_8h.html#a0e90290b709c86a39384ea5a4c95ac4f" title="This macro is used to terminate a state transition table. This table have the general structure shown...">RKH_END_TRANS_TABLE</a>
</pre></div><h3><a class="anchor" id="qrefsb_2"></a>
Declaring a submachine state</h3>
<div class="fragment"><pre class="fragment"><span class="comment">//  my.h: state-machine&#39;s header file</span>

...
RKH_DCLR_SUBM_STATE S12;
</pre></div><h3><a class="anchor" id="qrefsb_3"></a>
Defining the exit connection references</h3>
<p>Connection point references are sources/targets of transitions implying exits out of/entries into the submachine state machine referenced by a submachine state. In RKH every submachine state is associated with a exit point connection point reference table, which is composed of a well-defined set of exit point connection references. Thus, in RKH each row in a exit point table references an exit point pseudostate as defined in the submachine of the submachine state that has the exit point connection point defined. Note that each row number matches with the index number of the exit point pseudostate that it represent.</p>
<div class="fragment"><pre class="fragment"><span class="comment">// --- exit point pseudostates of SB submachine ---</span>
<a class="code" href="rkh_8h.html#a6fe42cdda8a3148e73f7eede949df02b" title="This macro creates an exit point.">RKH_CREATE_REF_EXPNT</a>(   EXPNT1, 
                        0,          <span class="comment">// index of exit point connection table</span>
                        &amp;SB );
<a class="code" href="rkh_8h.html#a6fe42cdda8a3148e73f7eede949df02b" title="This macro creates an exit point.">RKH_CREATE_REF_EXPNT</a>(   EXPNT2, 
                        1,          <span class="comment">// index of exit point connection table</span>
                        &amp;SB );
...
<span class="comment">// --- exit point connection references of S12 submachine state ---</span>
(1) <a class="code" href="rkh_8h.html#aa3f5f174502580a9edfb478612ef55a4" title="This macro creates a exit point connection point reference table. This table have the general structu...">RKH_CREATE_EX_CNNPNT_TABLE</a>( S12 )
(2)     <a class="code" href="rkh_8h.html#a52faf20342a2e105698b7b4c50952ba1" title="This macro creates an exit point connection point reference.">RKH_EX_CNNPNT</a>( EX1S12, &amp;EXPNT1, act1, &amp;S13 ), <span class="comment">// table index = 0 (EXPNT1)</span>
(3)     <a class="code" href="rkh_8h.html#a52faf20342a2e105698b7b4c50952ba1" title="This macro creates an exit point connection point reference.">RKH_EX_CNNPNT</a>( EX2S12, &amp;EXPNT2, act2, &amp;S3 ),  <span class="comment">// table index = 1 (EXPNT2)</span>
(4) <a class="code" href="rkh_8h.html#a2b628df718de30cfd38b26a23155a84a" title="This macro is used to terminate a exit point connection reference table. This table have the general ...">RKH_END_EX_CNNPNT_TABLE</a>
</pre></div><p>Explanation</p>
<ul>
<li>(1) The <a class="el" href="rkh_8h.html#aa3f5f174502580a9edfb478612ef55a4" title="This macro creates a exit point connection point reference table. This table have the general structu...">RKH_CREATE_EX_CNNPNT_TABLE()</a> macro creates the <code>S12's</code> exit point connection reference table. Each exit point connection reference table always begins with the macro <a class="el" href="rkh_8h.html#aa3f5f174502580a9edfb478612ef55a4" title="This macro creates a exit point connection point reference table. This table have the general structu...">RKH_CREATE_EX_CNNPNT_TABLE()</a> and ends with the macro <a class="el" href="rkh_8h.html#a2b628df718de30cfd38b26a23155a84a" title="This macro is used to terminate a exit point connection reference table. This table have the general ...">RKH_END_EX_CNNPNT_TABLE</a>. As noted above, sandwiched between these macros are the exit point macros, <a class="el" href="rkh_8h.html#a52faf20342a2e105698b7b4c50952ba1" title="This macro creates an exit point connection point reference.">RKH_EX_CNNPNT()</a>.</li>
</ul>
<ul>
<li>(2) The <a class="el" href="rkh_8h.html#a52faf20342a2e105698b7b4c50952ba1" title="This macro creates an exit point connection point reference.">RKH_EX_CNNPNT()</a> macro defines the exit point connection <code>EX1S12</code>, where <code>EXPNT1</code> is the referenced exit point pseudostate, <code>act1()</code> is the transition action function to be taken, and <code>S13</code> is the transition target state. The place in the table matches with the <code>EXPNT1's</code> index field.</li>
</ul>
<ul>
<li>(3) Idem (2).</li>
</ul>
<ul>
<li>(4) The <a class="el" href="rkh_8h.html#a2b628df718de30cfd38b26a23155a84a" title="This macro is used to terminate a exit point connection reference table. This table have the general ...">RKH_END_EX_CNNPNT_TABLE</a> macro ends exit point connection reference table.</li>
</ul>
<h3><a class="anchor" id="qrefsb_4"></a>
Defining the entry connection references</h3>
<p>Connection point references are sources/targets of transitions implying exits out of/entries into the submachine state machine referenced by a submachine state.</p>
<p>A entry point connection reference is defined with the <a class="el" href="rkh_8h.html#ab2920eb4e81a05b2002a9f49a44a3394" title="This macro creates an entry point connection point reference.">RKH_EN_CNNPNT()</a> macro and declared with the <a class="el" href="rkh_8h.html#abbe3ba8a8a32cc7359ce715568e44cae" title="Declares a previously created state/pseudostate to be used as a global object.">RKH_DCLR_ENPNT</a> macro. Frequently, each state machine and its states and pseudostates are encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#ab2920eb4e81a05b2002a9f49a44a3394" title="This macro creates an entry point connection point reference.">RKH_EN_CNNPNT()</a> macro is used. We will develop one example of entry point connection definition to illustrate the use of this macro. We will give our entry connection the name <code>ENS12</code>.</p>
<div class="fragment"><pre class="fragment">(1) <span class="comment">//  my.c: state-machine&#39;s module</span>

(2) <a class="code" href="rkh_8h.html#ab2920eb4e81a05b2002a9f49a44a3394" title="This macro creates an entry point connection point reference.">RKH_EN_CNNPNT</a>(  ENS12, 
                    &amp;ENPNT, 
                    &amp;S12 );
</pre></div><p>Explanation</p>
<ul>
<li>(1) Frequently, each state machine and its states are encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#ab2920eb4e81a05b2002a9f49a44a3394" title="This macro creates an entry point connection point reference.">RKH_EN_CNNPNT()</a> macro is used. </li>
<li>(2) The <a class="el" href="rkh_8h.html#ab2920eb4e81a05b2002a9f49a44a3394" title="This macro creates an entry point connection point reference.">RKH_EN_CNNPNT()</a> macro defines the exit point connection <code>ENS12</code>, where <code>ENPNT</code> is the referenced entry point pseudostate, and <code>S12</code> is the transition target state.</li>
</ul>
<h3><a class="anchor" id="qrefsb_5"></a>
Declaring entry connection references</h3>
<div class="fragment"><pre class="fragment"><span class="comment">//  my.h: state-machine&#39;s header file</span>

...
RKH_DCLR_ENPNT ENS12;
</pre></div><h3><a class="anchor" id="qrefsb_6"></a>
Defining a submachine</h3>
<p>A submachine is defined with the <a class="el" href="rkh_8h.html#a72b7267205521b0be8f113e8832a9440" title="This macro creates a submachine state machine, which is to be inserted in place of the (submachine) s...">RKH_CREATE_REF_SUBMACHINE()</a> macro and declared with the <a class="el" href="rkh_8h.html#ae64a1788046bd972dd4e2e905c1d67ea" title="Declares a previously created state/pseudostate to be used as a global object.">RKH_DCLR_REF_SUBM</a> macro. Frequently, each state machine and its states (composites, basic, and submachine states) are encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#a72b7267205521b0be8f113e8832a9440" title="This macro creates a submachine state machine, which is to be inserted in place of the (submachine) s...">RKH_CREATE_REF_SUBMACHINE()</a> macro is used. We will develop one example of submachine definition to illustrate the usage and its related macros. We will give our submachine the name <code>SB</code>.</p>
<div class="fragment"><pre class="fragment">(1) <span class="comment">//  my.c: state-machine&#39;s module</span>

(2) <a class="code" href="rkh_8h.html#a72b7267205521b0be8f113e8832a9440" title="This macro creates a submachine state machine, which is to be inserted in place of the (submachine) s...">RKH_CREATE_REF_SUBMACHINE</a>(  SB, 
(3)                             0, 
(4)                             &amp;SB1, 
(5)                             NULL );
</pre></div><p>Explanation</p>
<ul>
<li>(1) Frequently, each state machine and its states are encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#a72b7267205521b0be8f113e8832a9440" title="This macro creates a submachine state machine, which is to be inserted in place of the (submachine) s...">RKH_CREATE_REF_SUBMACHINE()</a> macro is used. </li>
<li>(2) <code>SB</code> is the submachine name. Represents a submachine structure. </li>
<li>(3) <code>0</code> is the value of submachine ID. </li>
<li>(4) <code>SB1</code> is the default state of <code>SB</code> submachine. At each level of nesting, a submachine can have a private initial transition that designates the active substate after the submachine is entered directly. Here the initial transition of state <code>SB</code> designates the state <code>SB1</code> as the initial active substate. </li>
<li>(5) the initialization action is not used.</li>
</ul>
<h3><a class="anchor" id="qrefsb_7"></a>
Declaring a submachine</h3>
<div class="fragment"><pre class="fragment"><span class="comment">//  my.h: state-machine&#39;s header file</span>

...
RKH_DCLR_REF_SUBM SB;
</pre></div><h3><a class="anchor" id="qrefsb_8"></a>
Defining the exit point</h3>
<p>A exit point pseudostate is defined with the <a class="el" href="rkh_8h.html#a6fe42cdda8a3148e73f7eede949df02b" title="This macro creates an exit point.">RKH_CREATE_REF_EXPNT()</a> macro and declared with the <a class="el" href="rkh_8h.html#aaa577ea93366c43f8fa3f801c464ba5d" title="Declares a previously created state/pseudostate to be used as a global object.">RKH_DCLR_REF_EXPNT</a> macro. Frequently, each state machine and its states and pseudostates are encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#a6fe42cdda8a3148e73f7eede949df02b" title="This macro creates an exit point.">RKH_CREATE_REF_EXPNT()</a> macro is used. We will develop one example of exit point definition to illustrate the use of this macro. We will give our exit points the name <code>EXPNT1</code> and <code>EXPNT2</code>.</p>
<div class="fragment"><pre class="fragment">(1) <span class="comment">//  my.c: state-machine&#39;s module</span>

(2) <a class="code" href="rkh_8h.html#a6fe42cdda8a3148e73f7eede949df02b" title="This macro creates an exit point.">RKH_CREATE_REF_EXPNT</a>(   EXPNT1, 
                            0, 
                            &amp;SB );
    <a class="code" href="rkh_8h.html#a6fe42cdda8a3148e73f7eede949df02b" title="This macro creates an exit point.">RKH_CREATE_REF_EXPNT</a>(   EXPNT2, 
                            1, 
                            &amp;SB );
</pre></div><p>Explanation</p>
<ul>
<li>(1) Frequently, each state machine and its states are encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#ab2920eb4e81a05b2002a9f49a44a3394" title="This macro creates an entry point connection point reference.">RKH_EN_CNNPNT()</a> macro is used. </li>
<li>(2) The <a class="el" href="rkh_8h.html#a6fe42cdda8a3148e73f7eede949df02b" title="This macro creates an exit point.">RKH_CREATE_REF_EXPNT()</a> macro defines the exit point <code>EXPNT1</code>, where <code>0</code> is the index of the exit point connection table, and <code>SB</code> is the containing submachine. See <a class="el" href="qref.html#qrefsb_5">Declaring entry connection references</a> for referencing a submachine exit point from a submachine state.</li>
</ul>
<h3><a class="anchor" id="qrefsb_9"></a>
Declaring a submachine</h3>
<div class="fragment"><pre class="fragment"><span class="comment">//  my.h: state-machine&#39;s header file</span>

...
RKH_DCLR_REF_EXPNT EXPNT1, EXPNT2;
</pre></div><h3><a class="anchor" id="qrefsb_10"></a>
Defining the entry point</h3>
<p>A entry point pseudostate is defined with the <a class="el" href="rkh_8h.html#a7d5fb4c1cd362a3be3f07db0fc31caac" title="This macro creates a entry point.">RKH_CREATE_REF_ENPNT()</a> macro and declared with the <a class="el" href="rkh_8h.html#a460aedcac6fc4799d4c14a33c2971ead" title="Declares a previously created state/pseudostate to be used as a global object.">RKH_DCLR_REF_ENPNT</a> macro. Frequently, each state machine and its states and pseudostates are encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#a7d5fb4c1cd362a3be3f07db0fc31caac" title="This macro creates a entry point.">RKH_CREATE_REF_ENPNT()</a> macro is used. We will develop one example of entry point definition to illustrate the use of this macro. We will give our entry point the name <code>ENPNT</code>.</p>
<div class="fragment"><pre class="fragment">(1) <span class="comment">//  my.c: state-machine&#39;s module</span>

(2) <a class="code" href="rkh_8h.html#a7d5fb4c1cd362a3be3f07db0fc31caac" title="This macro creates a entry point.">RKH_CREATE_REF_ENPNT</a>(   ENPNT, 
                            act8,
                            &amp;SB1,
                            &amp;SB );
</pre></div><p>Explanation</p>
<ul>
<li>(1) Frequently, each state machine and its states are encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#a7d5fb4c1cd362a3be3f07db0fc31caac" title="This macro creates a entry point.">RKH_CREATE_REF_ENPNT()</a> macro is used. </li>
<li>(2) The <a class="el" href="rkh_8h.html#a7d5fb4c1cd362a3be3f07db0fc31caac" title="This macro creates a entry point.">RKH_CREATE_REF_ENPNT()</a> macro defines the entry point <code>ENPNT</code>, where <code>activate()</code> is the transition action to be taken, <code>SB1</code> is the transition target state, and <code>SB</code> is the containing submachine.</li>
</ul>
<h3><a class="anchor" id="qrefsb_11"></a>
Declaring a entry point</h3>
<div class="fragment"><pre class="fragment"><span class="comment">//  my.h: state-machine&#39;s header file</span>

...
RKH_DCLR_REF_ENPNT ENPNT;
</pre></div><h3><a class="anchor" id="qrefsb_c"></a>
Customization</h3>
<p>Each RKH application must have its own configuration file, called <b><a class="el" href="rkhcfg_8h.html" title="RKH user configuration.">rkhcfg.h</a></b>. This file adapts and configures RKH by means of compiler definitions and macros allowing to restrict the resources consumed by RKH. Adjusting this definitions allows to reduce the ROM and RAM consumption, and to enhance the system performance in a substantial manner. The <b><a class="el" href="rkhcfg_8h.html" title="RKH user configuration.">rkhcfg.h</a></b> shows the general layout of the configuration file.</p>
<p>Use the following macros to reduce the memory taken by state machine structure. See <a class="el" href="cfg.html">Configuration</a> section for more information.</p>
<ul>
<li><b>RKH_SMA_EN_HCAL:</b> <br/>
 <p>If the <a class="el" href="rkhcfg_8h.html#a00535ac251d2e68808387c969263a979">RKH_SMA_EN_HCAL</a> is set to 1, the RKH allows state nesting. When <a class="el" href="rkhcfg_8h.html#a00535ac251d2e68808387c969263a979">RKH_SMA_EN_HCAL</a> is set to 0 some important features of RKH are not included: state nesting, composite state, history (shallow and deep) pseudostate, entry action, and exit action. </p>
</li>
<li><b>RKH_SMA_EN_PSEUDOSTATE:</b> <br/>
 <p>If the <a class="el" href="rkhcfg_8h.html#a0f83ea3d5082124eecffff121c83fb06">RKH_SMA_EN_PSEUDOSTATE</a> is set to 1, the RKH allows pseudostates usage. </p>
</li>
<li><b>RKH_SMA_EN_SUBMACHINE:</b> <br/>
 <p>If the <a class="el" href="rkhcfg_8h.html#abe2d11024bbc82140771d604982c9032">RKH_SMA_EN_SUBMACHINE</a> and <a class="el" href="rkhcfg_8h.html#a0f83ea3d5082124eecffff121c83fb06">RKH_SMA_EN_PSEUDOSTATE</a> are set to 1, the RKH allows submachine state (and exit/entry points) usage. </p>
</li>
<li><b>RKH_SMA_EN_STATE_ID:</b> <br/>
 <p>If the <a class="el" href="rkhcfg_8h.html#ad91978a11e63d6ff681583c5b045c154">RKH_SMA_EN_STATE_ID</a> is set to 1 then RKH allows to add a numerical value to every state and pseudostate. This number allows to uniquely identify a state and/or pseudostate. </p>
</li>
</ul>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<hr/>
 <h2><a class="anchor" id="qref16"></a>
Defining a state transition table</h2>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<p>In RKH every state is associated with a transition table, which is composed of a well-defined set of transitions. The general syntax of an expression labelling a transition in a statechart is <em>"i[c]/a"</em> where <em>i</em> is the input that triggers the transition, <em>c</em> is a condition that guards the transition from being taken unless it is true when <em>i</em> occurs, and <em>a</em> is an action that is carried out if and when the transition is taken. All of these parts are optional. Thus, in RKH each row in a table represents a transition, which is well-defined by an <em>event</em>, a <em>guard</em>, an <em>action</em>, and <em>target</em> state (or pseudostate). The <a class="el" href="qref.html#fig_trtbl">Transition table</a> figure shows a demostrative example of that.</p>
<p><a class="anchor" id="fig_trtbl"></a></p>
<div class="image">
<img src="trtbl.jpg" alt="trtbl.jpg"/>
<div class="caption">
Transition table</div></div>
 <ul>
<li>(1) Expressing this transition as said above:<br/>
<br/>
 <em>RCV_DATA[ data == SYNC ]/store_data( data )</em><br/>
<br/>
 The <code>data</code> <code>==</code> <code>SYNC</code> expression guards the transition from being taken unless it is true. The <code>store_data()</code> function is the action to be taken. Note that in RKH the guard condition is evaluated invoking to a function.</li>
</ul>
<ul>
<li>(2) Expressing this transition as said above:<br/>
<br/>
 <em>TOUT0/drop_frame()</em><br/>
<br/>
 This transition is not conditioned by a guard.</li>
</ul>
<ul>
<li>(3) Expressing this transition as said above:<br/>
<br/>
 <em>DISABLE/disable()</em><br/>
<br/>
 Similar to prior transition.</li>
</ul>
<p>Now, is time to represent IN_DATA's transition table by means of RKH framework:</p>
<div class="fragment"><pre class="fragment">(1) <a class="code" href="rkh_8h.html#aef55bd044383009972f38c332f8210a9" title="This macro creates a state transition table. This table have the general structure shown below:...">RKH_CREATE_TRANS_TABLE</a>( IN_DATA )
(2)     <a class="code" href="rkh_8h.html#ac257d157f98ef172e5e8c8725a293bdf" title="This macro defines an internal state transition. Internal transitions are simple reactions to events ...">RKH_TRINT</a>( RCV_DATA,    is_sync,    store_data              ),
(3)     <a class="code" href="rkh_8h.html#ab0fc2ccb4b73d57ea0c0f478353a00f6" title="This macro defines a regular state transition. The general syntax of an expression labelling a transi...">RKH_TRREG</a>( TOUT0,       NULL,       drop_frame, &amp;WAIT_SYNC  ),
        <a class="code" href="rkh_8h.html#ab0fc2ccb4b73d57ea0c0f478353a00f6" title="This macro defines a regular state transition. The general syntax of an expression labelling a transi...">RKH_TRREG</a>( DISABLE,     NULL,       disable,    &amp;IDLE       )
(4) <a class="code" href="rkh_8h.html#a0e90290b709c86a39384ea5a4c95ac4f" title="This macro is used to terminate a state transition table. This table have the general structure shown...">RKH_END_TRANS_TABLE</a>
</pre></div><p>Explanation</p>
<ul>
<li>(1) The <a class="el" href="rkh_8h.html#aef55bd044383009972f38c332f8210a9" title="This macro creates a state transition table. This table have the general structure shown below:...">RKH_CREATE_TRANS_TABLE()</a> macro creates the <code>IN_DATA's</code> transition table. Each transition table always begins with the macro <a class="el" href="rkh_8h.html#aef55bd044383009972f38c332f8210a9" title="This macro creates a state transition table. This table have the general structure shown below:...">RKH_CREATE_TRANS_TABLE()</a> and ends with the macro <a class="el" href="rkh_8h.html#a0e90290b709c86a39384ea5a4c95ac4f" title="This macro is used to terminate a state transition table. This table have the general structure shown...">RKH_END_TRANS_TABLE()</a>. As noted above, sandwiched between these macros are the transitions macros that actually represent behavior of state.</li>
</ul>
<ul>
<li>(2) The <a class="el" href="rkh_8h.html#ac257d157f98ef172e5e8c8725a293bdf" title="This macro defines an internal state transition. Internal transitions are simple reactions to events ...">RKH_TRINT()</a> macro defines a internal transition, where <code>RCV_DATA</code> is the triggering event, <code>is_sync</code> is the guard function, and <code>store_data()</code> is the action function to be taken.</li>
</ul>
<ul>
<li>(3) The <a class="el" href="rkh_8h.html#ab0fc2ccb4b73d57ea0c0f478353a00f6" title="This macro defines a regular state transition. The general syntax of an expression labelling a transi...">RKH_TRREG()</a> macro defines a regular state transition, where <code>TOUT0</code> is the triggering event, <code>drop_frame()</code> is the action function to be taken, and <code>WAIT_SYNC</code> is the target state. Note that it is not guarded.</li>
</ul>
<ul>
<li>(4) The <a class="el" href="rkh_8h.html#a0e90290b709c86a39384ea5a4c95ac4f" title="This macro is used to terminate a state transition table. This table have the general structure shown...">RKH_END_TRANS_TABLE()</a> macro ends transition table.</li>
</ul>
<p>As said above, the actions and guards in RKH framework are represented by functions. Thus, <code>is_sync()</code> could be declared as:</p>
<div class="fragment"><pre class="fragment">HUInt 
is_sync( <a class="code" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> *pe )
{
    <span class="keywordflow">return</span> pe-&gt;<a class="code" href="struct_r_k_h_e_v_t___t.html#ace79af9a2276cf72d7accf7f8f2c957e">e</a> == SYNC;
}
</pre></div><p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<hr/>
 <h2><a class="anchor" id="qref3"></a>
Defining a conditional pseudostate</h2>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<p>A conditional pseudostate (also called choice pseudostate) is defined with the <a class="el" href="rkh_8h.html#ade7387dead9112bd67580de3350aee51" title="This macro creates a conditional pseudostate.">RKH_CREATE_COND_STATE()</a> macro and declared with the <a class="el" href="rkh_8h.html#ae15f169feaafe7cf7e335e24e76039b9" title="Declares a previously created state/pseudostate to be used as a global object.">RKH_DCLR_COND_STATE</a> macro. Frequently, each state machine and its states and pseudostates are encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#ade7387dead9112bd67580de3350aee51" title="This macro creates a conditional pseudostate.">RKH_CREATE_COND_STATE()</a> macro is used. We will develop one example of choice pseudostate definition to illustrate the use of this macro. We will give our choice pseudostate the name <code>C1</code>. As will demostrates the use of <a class="el" href="rkh_8h.html#ade7387dead9112bd67580de3350aee51" title="This macro creates a conditional pseudostate.">RKH_CREATE_COND_STATE()</a> macro and its arguments is very similar to <a class="el" href="rkh_8h.html#a3567a7f91a5dc5759747dc8528357b44" title="This macro creates a basic state.">RKH_CREATE_BASIC_STATE()</a> macro.</p>
<p><b>Defining a choice pseudostate</b> </p>
<div class="fragment"><pre class="fragment">(1) <span class="comment">//  my.c: state-machine&#39;s module</span>

(2) <a class="code" href="rkh_8h.html#ade7387dead9112bd67580de3350aee51" title="This macro creates a conditional pseudostate.">RKH_CREATE_COND_STATE</a>(  C1, 
(3)                         0 );
</pre></div><p><b>Declaring a choice pseudostate</b> </p>
<div class="fragment"><pre class="fragment"><span class="comment">//  my.h: state-machine&#39;s header file</span>

...
RKH_DCLR_COND_STATE C1;
</pre></div><p>Explanation</p>
<ul>
<li>(1) Frequently, each state machine and its states are encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#a3567a7f91a5dc5759747dc8528357b44" title="This macro creates a basic state.">RKH_CREATE_BASIC_STATE()</a> macro is used. </li>
<li>(2) <code>C1</code> is the pseudostate name. Represents a choice pseudostate structure. </li>
<li>(3) <code>0</code> is the value of pseudostate ID.</li>
</ul>
<p><b>Customization</b> </p>
<p>Each RKH application must have its own configuration file, called <b><a class="el" href="rkhcfg_8h.html" title="RKH user configuration.">rkhcfg.h</a></b>. This file adapts and configures RKH by means of compiler definitions and macros allowing to restrict the resources consumed by RKH. Adjusting this definitions allows to reduce the ROM and RAM consumption, and to enhance the system performance in a substantial manner. The <b><a class="el" href="rkhcfg_8h.html" title="RKH user configuration.">rkhcfg.h</a></b> shows the general layout of the configuration file.</p>
<p>Use the following macros to reduce the memory taken by state machine structure. See <a class="el" href="cfg.html">Configuration</a> section for more information.</p>
<ul>
<li><b>RKH_SMA_EN_HCAL:</b> <br/>
 Enable (1) or disable (0) the state nesting. When RKH_SMA_EN_HCAL is set to one (1) some important features of RKH are not included: state composite state, history (shallow and deep) pseudostate, entry action, and exit action. <br/>
<br/>
</li>
<li><b>RKH_SMA_EN_STATE_ID:</b> <br/>
 When RKH_SMA_EN_STATE_ID is set to one (1) the state structure includes an ID number. This number allows to uniquely identify a state. <br/>
<br/>
</li>
<li><b>RKH_SMA_EN_PSEUDOSTATE:</b> <br/>
 Enable (1) or disable (0) the pseudostates usage.<br/>
<br/>
</li>
<li><b>RKH_SMA_EN_CONDITIONAL:</b> <br/>
 Enable (1) or disable (0) the conditional connector usage. <br/>
<br/>
</li>
<li><b>RKH_SMA_MAX_TR_SEGS:</b> <br/>
 Determines the maximum number of linked transition segments. The smaller this number, the lower the static RAM consumption. Typically, the most of hierarchical state machines uses up to 4 transition segments. Currently RKH_SMA_MAX_TR_SEGS cannot exceed 8.</li>
</ul>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<hr/>
 <h2><a class="anchor" id="qref17"></a>
Defining a branch table</h2>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<p>A condition connector has one incoming transition and can have several outgoing transition segments called branches. Branches are labeled with guards that determine which one is to be actually taken. Since the condition connector is an OR connector, only one of the branches can be taken. Each condition connector can have one special branch with a guard labeled rkh_else, which is taken if all the guards on the other branches are false. Branches cannot contain triggers, but in addition to a guard they may contain actions. A branch can enter another condition connector, thus providing for the nesting of branches. In RKH branches are defined by the macro <a class="el" href="rkh_8h.html#ad1ebb38b7398d7f4ec60ef3e0922d033" title="This macro defines a branch in the branch table.">RKH_BRANCH()</a>. The general syntax of an expression labelling a branch in a statechart is <em>"[c]/a"</em> where <em>c</em> is a condition that guards the transition from being taken unless it is true, and <em>a</em> is an action that is carried out if and when the transition is taken. All of these parts are optional. Example:</p>
<div class="fragment"><pre class="fragment">(1) <a class="code" href="rkh_8h.html#a57353c7dab6539b0a7ae92142b73ad2e">RKH_CREATE_BRANCH_TABLE</a>( C1 )
(2)     <a class="code" href="rkh_8h.html#ad1ebb38b7398d7f4ec60ef3e0922d033" title="This macro defines a branch in the branch table.">RKH_BRANCH</a>( power_ok,   enable_process, &amp;S22    ),
(3)     <a class="code" href="rkh_8h.html#ad1ebb38b7398d7f4ec60ef3e0922d033" title="This macro defines a branch in the branch table.">RKH_BRANCH</a>( <a class="code" href="rkh_8h.html#a0a70ee0cbf5b1738be4c9463c529ce72" title="Each condition connector can have one special branch with a guard labeled ELSE, which is taken if all...">ELSE</a>,       abort,          &amp;S4     ),
(4) <a class="code" href="rkh_8h.html#a179912e226da08c982c9e93d77886c53" title="This macro is used to terminate a state transition table. This table have the general structure shown...">RKH_END_BRANCH_TABLE</a>
</pre></div><p>Explanation</p>
<ul>
<li>(1) The <a class="el" href="rkh_8h.html#a57353c7dab6539b0a7ae92142b73ad2e">RKH_CREATE_BRANCH_TABLE()</a> macro creates the <code>C1's</code> branch table. Each table type always begins with the macro <a class="el" href="rkh_8h.html#a57353c7dab6539b0a7ae92142b73ad2e">RKH_CREATE_BRANCH_TABLE()</a> and ends with the macro <a class="el" href="rkh_8h.html#a179912e226da08c982c9e93d77886c53" title="This macro is used to terminate a state transition table. This table have the general structure shown...">RKH_END_BRANCH_TABLE()</a>. As noted above, sandwiched between these macros are the segment macros that actually comprise the condition connector.</li>
</ul>
<ul>
<li>(2) The <a class="el" href="rkh_8h.html#ad1ebb38b7398d7f4ec60ef3e0922d033" title="This macro defines a branch in the branch table.">RKH_BRANCH()</a> macro defines a branch segment, where <code>power_ok()</code> is the guard function, <code>enable_process</code> is the action function to be taken, and S22 is the target state.</li>
</ul>
<ul>
<li>(3) If all the guards on the other branches are false <code>abort()</code> function will be invoked, and <code>S4</code> will be the next state.</li>
</ul>
<ul>
<li>(4) The <a class="el" href="rkh_8h.html#a179912e226da08c982c9e93d77886c53" title="This macro is used to terminate a state transition table. This table have the general structure shown...">RKH_END_BRANCH_TABLE()</a> macro ends branch table.</li>
</ul>
<p>As said above, the actions and guards in RKH framework are represented by functions.</p>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<hr/>
 <h2><a class="anchor" id="qref4"></a>
Defining a shallow history pseudostate</h2>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<p>A shallow history pseudostate is defined with the <a class="el" href="rkh_8h.html#a7a5376dd9929642f5b6e31def6d92bb4" title="This macro creates a shallow history pseudostate.">RKH_CREATE_SHALLOW_HISTORY_STATE()</a> macro and declared with the <a class="el" href="rkh_8h.html#aa618e2849fbd748f672bd5e0b3b6bb16" title="Declares a previously created state/pseudostate to be used as a global object.">RKH_DCLR_SHIST_STATE</a> macro. Frequently, each state machine and its states and pseudostates are encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#a7a5376dd9929642f5b6e31def6d92bb4" title="This macro creates a shallow history pseudostate.">RKH_CREATE_SHALLOW_HISTORY_STATE()</a> macro is used. We will develop one example of shallow history pseudostate definition to illustrate the use of this macro. We will give our history pseudostate the name <code>H1</code>. As will demostrates the use of <a class="el" href="rkh_8h.html#a7a5376dd9929642f5b6e31def6d92bb4" title="This macro creates a shallow history pseudostate.">RKH_CREATE_SHALLOW_HISTORY_STATE()</a> macro and its arguments is very similar to <a class="el" href="rkh_8h.html#ade7387dead9112bd67580de3350aee51" title="This macro creates a conditional pseudostate.">RKH_CREATE_COND_STATE()</a> macro.</p>
<p><b>Defining a shallow history pseudostate</b> </p>
<div class="fragment"><pre class="fragment">(1) <span class="comment">//  my.c: state-machine&#39;s module</span>

(2) <a class="code" href="rkh_8h.html#a7a5376dd9929642f5b6e31def6d92bb4" title="This macro creates a shallow history pseudostate.">RKH_CREATE_SHALLOW_HISTORY_STATE</a>(   H1, 
(3)                                     6,
(4)                                     &amp;S1 );
</pre></div><p><b>Declaring a shallow history pseudostate</b> </p>
<div class="fragment"><pre class="fragment"><span class="comment">//  my.h: state-machine&#39;s header file</span>

...
RKH_DCLR_DHIST_STATE H1;
</pre></div><p>Explanation</p>
<ul>
<li>(1) Frequently, each state machine and its states are encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#a7a5376dd9929642f5b6e31def6d92bb4" title="This macro creates a shallow history pseudostate.">RKH_CREATE_SHALLOW_HISTORY_STATE()</a> macro is used. </li>
<li>(2) <code>H1</code> is the pseudostate name. Represents a shallow history pseudostate structure. </li>
<li>(3) <code>6</code> is the value of pseudostate ID. </li>
<li>(6) <code>S1</code> is the parent state of <code>H1</code>.</li>
</ul>
<p><b>Customization</b> </p>
<p>Each RKH application must have its own configuration file, called <b><a class="el" href="rkhcfg_8h.html" title="RKH user configuration.">rkhcfg.h</a></b>. This file adapts and configures RKH by means of compiler definitions and macros allowing to restrict the resources consumed by RKH. Adjusting this definitions allows to reduce the ROM and RAM consumption, and to enhance the system performance in a substantial manner. The <b><a class="el" href="rkhcfg_8h.html" title="RKH user configuration.">rkhcfg.h</a></b> shows the general layout of the configuration file. Use the following macros to reduce the memory taken by state machine structure. See <a class="el" href="cfg.html">Configuration</a> section for more information.</p>
<ul>
<li><b>RKH_SMA_EN_HCAL:</b> <br/>
 Enable (1) or disable (0) the state nesting. When RKH_SMA_EN_HCAL is set to one (1) some important features of RKH are not included: state composite state, history (shallow and deep) pseudostate, entry action, and exit action. <br/>
<br/>
</li>
<li><b>RKH_SMA_EN_STATE_ID:</b> <br/>
 When RKH_SMA_EN_STATE_ID is set to one (1) the state structure includes an ID number. This number allows to uniquely identify a state. <br/>
<br/>
</li>
<li><b>RKH_SMA_EN_PSEUDOSTATE:</b> <br/>
 Enable (1) or disable (0) the pseudostates usage. <br/>
<br/>
</li>
<li><b>RKH_SMA_MAX_TR_SEGS:</b> <br/>
 Determines the maximum number of linked transition segments. The smaller this number, the lower the static RAM consumption. Typically, the most of hierarchical state machines uses up to 4 transition segments. Currently RKH_SMA_MAX_TR_SEGS cannot exceed 8. <br/>
<br/>
</li>
<li><b>RKH_EN_SHALLOW_HISTORY:</b> <br/>
 Enable (1) or disable (0) the shallow history usage.</li>
</ul>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<hr/>
 <h2><a class="anchor" id="qref5"></a>
Defining a deep history pseudostate</h2>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<p>A deep history pseudostate is defined with the <a class="el" href="rkh_8h.html#a49995aa34cddd68fcc6416655ca408f8" title="This macro creates a deep history pseudostate.">RKH_CREATE_DEEP_HISTORY_STATE()</a> macro and declared with the <a class="el" href="rkh_8h.html#a042e46c64f90aa08a92db9e9d30e1959" title="Declares a previously created state/pseudostate to be used as a global object.">RKH_DCLR_DHIST_STATE</a> macro. Frequently, each state machine and its states and pseudostates are encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#a49995aa34cddd68fcc6416655ca408f8" title="This macro creates a deep history pseudostate.">RKH_CREATE_DEEP_HISTORY_STATE()</a> macro is used. We will develop one example of deep history pseudostate definition to illustrate the use of this macro. We will give our history pseudostate the name <code>H2</code>. As will demostrates the use of <a class="el" href="rkh_8h.html#a49995aa34cddd68fcc6416655ca408f8" title="This macro creates a deep history pseudostate.">RKH_CREATE_DEEP_HISTORY_STATE()</a> macro and its arguments is very similar to <a class="el" href="rkh_8h.html#a7a5376dd9929642f5b6e31def6d92bb4" title="This macro creates a shallow history pseudostate.">RKH_CREATE_SHALLOW_HISTORY_STATE()</a> macro.</p>
<p><b>Defining a deep history pseudostate</b> <br/>
 </p>
<div class="fragment"><pre class="fragment">(1) <span class="comment">//  my.c: state-machine&#39;s module</span>

(2) <a class="code" href="rkh_8h.html#a49995aa34cddd68fcc6416655ca408f8" title="This macro creates a deep history pseudostate.">RKH_CREATE_DEEP_HISTORY_STATE</a>(  H1, 
(3)                                 7,
(4)                                 &amp;S21 );
</pre></div><p><b>Declaring a shallow history pseudostate</b> </p>
<div class="fragment"><pre class="fragment"><span class="comment">//  my.h: state-machine&#39;s header file</span>

...
RKH_DCLR_DHIST_STATE H1;
</pre></div><p>Explanation</p>
<ul>
<li>(1) Frequently, each state machine and its states are encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#a49995aa34cddd68fcc6416655ca408f8" title="This macro creates a deep history pseudostate.">RKH_CREATE_DEEP_HISTORY_STATE()</a> macro is used. </li>
<li>(2) <code>H2</code> is the pseudostate name. Represents a deep history pseudostate structure. </li>
<li>(3) <code>7</code> is the value of pseudostate ID. </li>
<li>(6) <code>S21</code> is the parent state of <code>H2</code>.</li>
</ul>
<p><b>Customization</b> </p>
<p>Each RKH application must have its own configuration file, called <b><a class="el" href="rkhcfg_8h.html" title="RKH user configuration.">rkhcfg.h</a></b>. This file adapts and configures RKH by means of compiler definitions and macros allowing to restrict the resources consumed by RKH. Adjusting this definitions allows to reduce the ROM and RAM consumption, and to enhance the system performance in a substantial manner. The <b><a class="el" href="rkhcfg_8h.html" title="RKH user configuration.">rkhcfg.h</a></b> shows the general layout of the configuration file. Use the following macros to reduce the memory taken by state machine structure. See <a class="el" href="cfg.html">Configuration</a> section for more information.</p>
<ul>
<li><b>RKH_SMA_EN_HCAL:</b> <br/>
 Enable (1) or disable (0) the state nesting. When RKH_SMA_EN_HCAL is set to one (1) some important features of RKH are not included: state composite state, history (shallow and deep) pseudostate, entry action, and exit action. <br/>
<br/>
</li>
<li><b>RKH_SMA_EN_STATE_ID:</b> <br/>
 When RKH_SMA_EN_STATE_ID is set to one (1) the state structure includes an ID number. This number allows to uniquely identify a state. <br/>
<br/>
</li>
<li><b>RKH_SMA_EN_PSEUDOSTATE:</b> <br/>
 Enable (1) or disable (0) the pseudostates usage. <br/>
<br/>
</li>
<li><b>RKH_SMA_MAX_TR_SEGS:</b> <br/>
 Determines the maximum number of linked transition segments. The smaller this number, the lower the static RAM consumption. Typically, the most of hierarchical state machines uses up to 4 transition segments. Currently RKH_SMA_MAX_TR_SEGS cannot exceed 8. <br/>
<br/>
</li>
<li><b>RKH_EN_DEEP_HISTORY:</b> <br/>
 Enable (1) or disable (0) the deep history usage.</li>
</ul>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<hr/>
 <h2><a class="anchor" id="qref6"></a>
Defining a junction pseudostate</h2>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<p>A conditional pseudostate (also called branch pseudostate) is defined with the <a class="el" href="rkh_8h.html#a9f73c81d95a4bd5bec21e10ea6f05add" title="This macro creates a junction pseudostate.">RKH_CREATE_JUNCTION_STATE()</a> macro and declared with the <a class="el" href="rkh_8h.html#a2862a673eba565cd2888ca5fb3405a38" title="Declares a previously created state/pseudostate to be used as a global object.">RKH_DCLR_JUNC_STATE</a> macro. Frequently, each state machine and its states and pseudostates are encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#a9f73c81d95a4bd5bec21e10ea6f05add" title="This macro creates a junction pseudostate.">RKH_CREATE_JUNCTION_STATE()</a> macro is used. We will develop one example of junction pseudostate definition to illustrate the use of this macro. We will give our junction pseudostate the name <code>J1</code>. As will demostrates the use of <a class="el" href="rkh_8h.html#a9f73c81d95a4bd5bec21e10ea6f05add" title="This macro creates a junction pseudostate.">RKH_CREATE_JUNCTION_STATE()</a> macro and its arguments is very similar to <a class="el" href="rkh_8h.html#a3567a7f91a5dc5759747dc8528357b44" title="This macro creates a basic state.">RKH_CREATE_BASIC_STATE()</a> macro.</p>
<p><b>Defining a junction pseudostate</b> <br/>
 </p>
<div class="fragment"><pre class="fragment">(1) <span class="comment">//  my.c: state-machine&#39;s module</span>

(2) <a class="code" href="rkh_8h.html#a9f73c81d95a4bd5bec21e10ea6f05add" title="This macro creates a junction pseudostate.">RKH_CREATE_JUNCTION_STATE</a>(  J1, 
(3)                             8, 
(4)                             dis_all_modules, 
(6)                             &amp;S1 );
</pre></div><p><b>Declaring a junction pseudostate</b> </p>
<div class="fragment"><pre class="fragment"><span class="comment">//  my.h: state-machine&#39;s header file</span>

...
RKH_DCLR_JUNC_STATE J1;
</pre></div><p>Explanation</p>
<ul>
<li>(1) Frequently, each state machine and its states are encapsulated inside a dedicated source file (.c file), from which the <a class="el" href="rkh_8h.html#a9f73c81d95a4bd5bec21e10ea6f05add" title="This macro creates a junction pseudostate.">RKH_CREATE_JUNCTION_STATE()</a> macro is used. </li>
<li>(2) <code>J1</code> is the pseudostate name. Represents a junction pseudostate structure. </li>
<li>(3) <code>8</code> is the value of pseudostate ID. </li>
<li>(4) <code>dis_all_modules</code> segment action to be taken. This argument is optional, thus it could be declared as NULL. </li>
<li>(5) <code>S1</code> is the target state.</li>
</ul>
<p><b>Customization</b> </p>
<p>Each RKH application must have its own configuration file, called <b><a class="el" href="rkhcfg_8h.html" title="RKH user configuration.">rkhcfg.h</a></b>. This file adapts and configures RKH by means of compiler definitions and macros allowing to restrict the resources consumed by RKH. Adjusting this definitions allows to reduce the ROM and RAM consumption, and to enhance the system performance in a substantial manner. The <b><a class="el" href="rkhcfg_8h.html" title="RKH user configuration.">rkhcfg.h</a></b> shows the general layout of the configuration file.</p>
<p>Use the following macros to reduce the memory taken by state machine structure. See <a class="el" href="cfg.html">Configuration</a> section for more information.</p>
<ul>
<li><b>RKH_SMA_EN_HCAL:</b> <br/>
 Enable (1) or disable (0) the state nesting. When RKH_SMA_EN_HCAL is set to one (1) some important features of RKH are not included: state composite state, history (shallow and deep) pseudostate, entry action, and exit action. <br/>
<br/>
</li>
<li><b>RKH_SMA_EN_STATE_ID:</b> <br/>
 When RKH_SMA_EN_STATE_ID is set to one (1) the state structure includes an ID number. This number allows to uniquely identify a state. <br/>
<br/>
</li>
<li><b>RKH_SMA_EN_PSEUDOSTATE:</b> <br/>
 Enable (1) or disable (0) the pseudostates usage. <br/>
<br/>
</li>
<li><b>RKH_SMA_MAX_TR_SEGS:</b> <br/>
 Determines the maximum number of linked transition segments. The smaller this number, the lower the static RAM consumption. Typically, the most of hierarchical state machines uses up to 4 transition segments. Currently RKH_SMA_MAX_TR_SEGS cannot exceed 8. <br/>
<br/>
</li>
<li><b>RKH_EN_JUNCTION:</b> <br/>
 Enable (1) or disable (0) the junction connector usage.</li>
</ul>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<hr/>
 <h2><a class="anchor" id="qref14"></a>
Defining entry, exit, and transition actions</h2>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<p>This section summarize the functions and its prototypes used by RKH framework. As mentioned before, the framework make use the callbacks, i.e. pointer to functions, in most of its data structures by means of <a class="el" href="rkh_8h.html#ae6c326c33b1cc4acf2529c628ba8c2aa" title="Declare and allocate a SMA (active object) derived from RKHSMA_T. Also, initializes and assigns a sta...">RKH_SMA_CREATE()</a>, <a class="el" href="rkh_8h.html#acc24b2221cd374e66732a09fb24b56ce" title="This macro creates a composite state.">RKH_CREATE_COMP_STATE()</a>, <a class="el" href="rkh_8h.html#a3567a7f91a5dc5759747dc8528357b44" title="This macro creates a basic state.">RKH_CREATE_BASIC_STATE()</a>, <a class="el" href="rkh_8h.html#ac257d157f98ef172e5e8c8725a293bdf" title="This macro defines an internal state transition. Internal transitions are simple reactions to events ...">RKH_TRINT()</a>, <a class="el" href="rkh_8h.html#ab0fc2ccb4b73d57ea0c0f478353a00f6" title="This macro defines a regular state transition. The general syntax of an expression labelling a transi...">RKH_TRREG()</a>, <a class="el" href="rkh_8h.html#ad1ebb38b7398d7f4ec60ef3e0922d033" title="This macro defines a branch in the branch table.">RKH_BRANCH()</a>, <a class="el" href="rkh_8h.html#a7a5376dd9929642f5b6e31def6d92bb4" title="This macro creates a shallow history pseudostate.">RKH_CREATE_SHALLOW_HISTORY_STATE()</a>, <a class="el" href="rkh_8h.html#a49995aa34cddd68fcc6416655ca408f8" title="This macro creates a deep history pseudostate.">RKH_CREATE_DEEP_HISTORY_STATE()</a>, and <a class="el" href="rkh_8h.html#a9f73c81d95a4bd5bec21e10ea6f05add" title="This macro creates a junction pseudostate.">RKH_CREATE_JUNCTION_STATE()</a> macros. Obviously, the set of available functions and its configurations is mandatory to known for properly using the framework.</p>
<p><b>Initialization action</b></p>
<p>Frequently, the state transition originating at the black ball is called the initial transition. Such transition designates the first active state after the state machine object is created. An initial transition can have associated actions, which in the UML notation are enlisted after the forward slash (/). In RKH framework, the application code must trigger the initial transition explicitly by invoking <a class="el" href="rkh_8h.html#a02d78c8f4c9f8e2b9fb0cf57711c1220" title="Initializes and activates a previously created state machine application.">rkh_sma_activate()</a> function. </p>
<p>As said above, the application must explicitly trigger initial transitions in all state machines. The following listing shows the use of <a class="el" href="rkh_8h.html#a02d78c8f4c9f8e2b9fb0cf57711c1220" title="Initializes and activates a previously created state machine application.">rkh_sma_activate()</a> function, when it's is called the initial action is invoked and the state machine start. The <a class="el" href="rkh_8h.html#a02d78c8f4c9f8e2b9fb0cf57711c1220" title="Initializes and activates a previously created state machine application.">rkh_sma_activate()</a> is a platform-dependent function. All RKH ports must be defined in the RKH port file to a particular platform. However, only the ports to the external OS/RTOS usually need some code to bolt the framework to the external OS/RTOS.</p>
<div class="fragment"><pre class="fragment"><span class="comment">// start the manager state machine application</span>
<a class="code" href="rkh_8h.html#a02d78c8f4c9f8e2b9fb0cf57711c1220" title="Initializes and activates a previously created state machine application.">rkh_sma_activate</a>(   manager,        <span class="comment">// state machine application (SMA)</span>
                    qmgr,           <span class="comment">// event storage area for manager SMA</span>
                    QMGR_SIZE,      <span class="comment">// size of the storage area</span>
                    ( <span class="keywordtype">void</span> * )0,    <span class="comment">// not used</span>
                    0 );            <span class="comment">// not used</span>
</pre></div><p>The next listing shows an example of the initial action implementation.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> 
manager_init( <span class="keyword">const</span> <span class="keyword">struct</span> rkh_t *sma )
{
    dprint( <span class="stringliteral">&quot;Init \&quot;manager\&quot; state machine\n&quot;</span> );
    manager_turnon();   
}
</pre></div><p><b>Exit action</b></p>
<p>The actions that are always execute when a state is exited should be exit actions. UML statecharts provide optional entry and exit actions, which are associated with states rather than transitions, as in a Moore automaton. An exit function takes the state machine pointer as argument. This argument is optional, thus it could be eliminated in compile-time by means of RKH_SMA_EN_EXT_ARG_SMA.</p>
<p>The RKH implementation preserves the transition sequence imposed by Harel's Statechart and UML. Specifically, the implemented transition sequence is as follows:</p>
<p>1. Execute exit actions of the source state. 2. Execute the transition actions. 3. Execute entry actions of the target state.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This callback is referenced from <a class="el" href="rkh_8h.html#acc24b2221cd374e66732a09fb24b56ce" title="This macro creates a composite state.">RKH_CREATE_COMP_STATE()</a> and <a class="el" href="rkh_8h.html#a3567a7f91a5dc5759747dc8528357b44" title="This macro creates a basic state.">RKH_CREATE_BASIC_STATE()</a> macros. </dd></dl>
<p>The next listing shows an example of the exit action implementation.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> 
idle_exit( <span class="keyword">const</span> <span class="keyword">struct</span> rkh_t *sma )
{
    dprint( <span class="stringliteral">&quot;Exit from \&quot;IDLE\&quot; state\n&quot;</span> );
    manager_restore();
}
</pre></div><p><b>Entry action</b></p>
<p>The actions that are always executed when a state is entered should be specified as entry actions. UML statecharts provide optional entry and exit actions, which are associated with states rather than transitions, as in a Moore automaton. An entry function takes the state machine pointer as argument. This argument is optional, thus it could be eliminated in compile-time by means of RKH_SMA_EN_ENT_ARG_SMA.</p>
<p>The RKH implementation preserves the transition sequence imposed by Harel's Statechart and UML. Specifically, the implemented transition sequence is as follows:</p>
<p>1. Execute exit actions of the source state. 2. Execute the transition actions. 3. Execute entry actions of the target state.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This callback is referenced from <a class="el" href="rkh_8h.html#acc24b2221cd374e66732a09fb24b56ce" title="This macro creates a composite state.">RKH_CREATE_COMP_STATE()</a> and <a class="el" href="rkh_8h.html#a3567a7f91a5dc5759747dc8528357b44" title="This macro creates a basic state.">RKH_CREATE_BASIC_STATE()</a> macros. <b>RKH_SMA_EN_ENT_ARG_SMA</b> macro. </dd></dl>
<p>The next listing shows an example of the entry action implementation.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> 
wait_process_entry( <span class="keyword">const</span> <span class="keyword">struct</span> rkh_t *sma )
{
    dprint( <span class="stringliteral">&quot;Entry to \&quot;WAIT_PROCESS\&quot; state\n&quot;</span> );
    manager_deactivate();
}
</pre></div><p><b>Transition action</b></p>
<p>Transition actions are small atomic behaviors executed at specified points in a state machine. This actions are assumed to take an insignificant amount of time to execute and are noninterruptible. UML statecharts are extended state machines with characteristics of both Mealy and Moore automata. In statecharts, actions generally depend on both the state of the system and the triggering event, as in a Mealy automaton. Additionally, UML statecharts provide optional entry and exit actions, which are associated with states rather than transitions, as in a Moore automaton. An action function takes the state machine pointer and the event pointer as arguments. These arguments are optional, thus they could be eliminated in compile-time by means of RKH_SMA_EN_ACT_ARG_EVT and <b>RKH_SMA_EN_ACT_ARG_SMA</b>.</p>
<p>The RKH implementation preserves the transition sequence imposed by Harel's Statechart and UML. Specifically, the implemented transition sequence is as follows:</p>
<p>1. Execute exit actions of the source state. 2. Execute the transition actions. 3. Execute entry actions of the target state.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This callback is referenced from <a class="el" href="rkh_8h.html#ab0fc2ccb4b73d57ea0c0f478353a00f6" title="This macro defines a regular state transition. The general syntax of an expression labelling a transi...">RKH_TRREG()</a> and <a class="el" href="rkh_8h.html#ac257d157f98ef172e5e8c8725a293bdf" title="This macro defines an internal state transition. Internal transitions are simple reactions to events ...">RKH_TRINT()</a>macro. </dd></dl>
<p>The next listing shows an example of the transition action implementation.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> 
set_config( <span class="keyword">const</span> <span class="keyword">struct</span> rkh_t *sma, <a class="code" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> *pe )
{
    MYEVT_T *e;

    (void)sma;      <span class="comment">/* argument not used */</span>
    (void)pe;       <span class="comment">/* argument not used */</span>

    e = <a class="code" href="rkh_8h.html#a66808180348a0a822a0fa46328b7f7d9" title="This macro dynamically creates a new event of type et with its signal.">RKH_ALLOC_EVENT</a>( MYEVT_T, SIX );
    e-&gt;ts = ( rkhui16_t )rand();
    <a class="code" href="rkhtim_8h.html#a0afe1937501e53a2d04fcd751231d773" title="Start a timer as one-shot timer.">rkh_tim_oneshot</a>( &amp;my_timer, sma, MY_TICK );
}
</pre></div><p><b>Event preprocessor</b></p>
<p>Before sending the arrived event to state machine, it can be previously processed using the event preprocessor function. The RKH framework provides optional event preprocessor action, which are associated with states rather than transitions, as in a Moore automaton. This action takes the state machine pointer and the event pointer as arguments. This argument is optional, thus it could be eliminated in compile-time by means of RKH_SMA_EN_PPRO_ARG_SMA.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This callback is referenced from <a class="el" href="rkh_8h.html#acc24b2221cd374e66732a09fb24b56ce" title="This macro creates a composite state.">RKH_CREATE_COMP_STATE()</a> and <a class="el" href="rkh_8h.html#a3567a7f91a5dc5759747dc8528357b44" title="This macro creates a basic state.">RKH_CREATE_BASIC_STATE()</a> macros. </dd></dl>
<p>The next listing shows an example of the event preprocessor action implementation.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="rkhevt_8h.html#a8a78cec3a9dfc2336bd084c221e15e10">RKHE_T</a> 
preprocess_keys( <span class="keyword">const</span> <span class="keyword">struct</span> rkh_t *sma, <a class="code" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> *pe )
{
    <span class="keywordflow">if</span>( pe-&gt;<a class="code" href="struct_r_k_h_e_v_t___t.html#ace79af9a2276cf72d7accf7f8f2c957e">e</a> &gt;= 0 &amp;&amp; pe-&gt;<a class="code" href="struct_r_k_h_e_v_t___t.html#ace79af9a2276cf72d7accf7f8f2c957e">e</a> &lt;= 9 )
        <span class="keywordflow">return</span> DECIMAL;
    <span class="keywordflow">if</span>( pe-&gt;<a class="code" href="struct_r_k_h_e_v_t___t.html#ace79af9a2276cf72d7accf7f8f2c957e">e</a> == <span class="charliteral">&#39;.&#39;</span> )
        <span class="keywordflow">return</span> POINT;
    <span class="keywordflow">else</span>
        <span class="keywordflow">return</span> pe-&gt;<a class="code" href="struct_r_k_h_e_v_t___t.html#ace79af9a2276cf72d7accf7f8f2c957e">e</a>;
}
</pre></div><p><b>Guard</b></p>
<p>A guard is a boolean condition that returns a TRUE (RKH_GTRUE) or FALSE (RKH_GFALSE) value that controls whether or not a transition is taken following the receipt of a triggering event. A transition with a guard is only take if the triggering event occurs and the guard evaluates to TRUE. As long as the guard evaluated to FALSE, the triggering event would be discarded and the transition would not be taken. Each condition connector can have one special branch with a guard labeled rkh_else, which is taken if all the guards on the other branches are false. A guard function takes the state machine pointer and the event pointer as arguments. These arguments are optional, thus they could be eliminated in compile-time by means of <b>RKH_SMA_EN_GRD_ARG_EVT</b> and <b>RKH_SMA_EN_GRD_ARG_SMA</b>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This callback is referenced from <a class="el" href="rkh_8h.html#ad1ebb38b7398d7f4ec60ef3e0922d033" title="This macro defines a branch in the branch table.">RKH_BRANCH()</a> macro. </dd></dl>
<p>The next listing shows an example of the guard function implementation.</p>
<div class="fragment"><pre class="fragment">HUInt 
is_zero( <span class="keyword">const</span> <span class="keyword">struct</span> rkh_t *sma, <a class="code" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> *pe )
{
    <span class="keywordflow">return</span> get_water_level( CHANNEL( (( CHEVT_T* )pe)-&gt;ch ) ) == 0;
}
</pre></div><p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<hr/>
 <h2><a class="anchor" id="qref12"></a>
Using events with parameters</h2>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<p>An event can have associated parameters, allowing the event instance to convey not only the occurrence of some interesting incident but also quantitative information regarding that occurrence. Implementing the single inheritance in C is very simply by literally embedding the base structure, <a class="el" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> in this case, as the first member of the derived structure. For example, the structure MYEVT_T derived from the base structure <a class="el" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> by embedding the <a class="el" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> instance as the first member of MYEVT_T. See also, <a class="el" href="qref.html#qref7">Using dynamic and static events</a> section for more information.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">struct</span>
{
    <a class="code" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> evt;   <span class="comment">// base structure</span>
    <span class="keywordtype">int</span> x;          <span class="comment">// parameter &#39;x&#39;</span>
    <span class="keywordtype">int</span> y;          <span class="comment">// parameter &#39;y&#39;</span>
} MYEVT_T;
</pre></div><p>Such nesting of structures always aligns the data member 'evt' at the beginning of every instance of the derived structure. In particular, this alignment lets you treat a pointer to the derived MYEVT_T structure as a pointer to the <a class="el" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> base structure. Consequently, you can always safely pass a pointer to MYEVT_T to any C function that expects a pointer to <a class="el" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a>. (To be strictly correct in C, you should explicitly cast this pointer. In OOP such casting is called upcasting and is always safe.) Therefore, all functions designed for the <a class="el" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> structure are automatically available to the MYEVT_T structure as well as other structures derived from <a class="el" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a>.</p>
<p>The RKH takes the <em>'e'</em> member of <a class="el" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> structure for triggering a state transition.</p>
<p>See also rkh_sma_put_fifo(), rkh_sma_put_lifo(), <a class="el" href="rkh_8h.html#a66808180348a0a822a0fa46328b7f7d9" title="This macro dynamically creates a new event of type et with its signal.">RKH_ALLOC_EVENT()</a>, <a class="el" href="rkh_8h.html#a1e1ded09fc7d2c30b33a74ebccf1bc3e" title="This macro initialize an event e with es signal and establishes it as one static event.">RKH_SET_STATIC_EVENT()</a>, and <a class="el" href="rkh_8h.html#a5a62e6121174abd89d8a77b9ebef0736" title="Recycle a dynamic event.">RKH_GC()</a>.</p>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<hr/>
 <h2><a class="anchor" id="qref7"></a>
Using dynamic and static events</h2>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<p>In RKH as other frameworks, the actual event instances are either constant events (or static events) statically allocated at compile time or dynamic events allocated at runtime from one of the event pools that the framework manages.</p>
<p>This section includes:</p>
<ul>
<li><a class="el" href="qref.html#qref7_1">Registering the event pool</a></li>
<li><a class="el" href="qref.html#qref7_2">Allocating events</a></li>
<li><a class="el" href="qref.html#qref7_3">Posting events</a></li>
<li><a class="el" href="qref.html#qref7_4">Recycling dynamic events</a></li>
<li><a class="el" href="qref.html#qref7_5">Customization</a></li>
</ul>
<h3><a class="anchor" id="qref7_1"></a>
Registering the event pool</h3>
<p>Before using dynamic events (or event with arguments) the application code must register the proper event pools, which stores the events as a fixed-sized memory block. Each event pool must be registered with the RKH framework, by means of the <a class="el" href="rkh_8h.html#aafd0b47b3a410c6b89e499b39a28f874" title="Registers a new event pool into the event pool list.">rkh_epool_register()</a> function. This function initializes one event pool at a time and must be called exactly once for each event pool before the pool can be used.</p>
<p>The application code might initialize the event pools by making calls to the <a class="el" href="rkh_8h.html#aafd0b47b3a410c6b89e499b39a28f874" title="Registers a new event pool into the event pool list.">rkh_epool_register()</a> function. However, for the simplicity of the internal implementation, the application code initialize event pools in the ascending order of the event size.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#define SIZEOF_EP0STO               64</span>
<span class="preprocessor"></span><span class="preprocessor">#define SIZEOF_EP0_BLOCK            sizeof( TOUT_T )</span>
<span class="preprocessor"></span>
<span class="preprocessor">#define SIZEOF_EP1STO               32</span>
<span class="preprocessor"></span><span class="preprocessor">#define SIZEOF_EP1_BLOCK            sizeof( DIAL_T )</span>
<span class="preprocessor"></span>
<span class="preprocessor">#define SIZEOF_EP2STO               32</span>
<span class="preprocessor"></span><span class="preprocessor">#define SIZEOF_EP2_BLOCK            sizeof( SETUP_T )</span>
<span class="preprocessor"></span>
<span class="keyword">typedef</span> <span class="keyword">struct</span>
{
    <a class="code" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> evt;                   <span class="comment">// base structure</span>
    <span class="keywordtype">int</span> timerno;                    <span class="comment">// parameter &#39;timerno&#39;</span>
} TOUT_T;

<span class="keyword">typedef</span> <span class="keyword">struct</span>
{
    <a class="code" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> evt;                   <span class="comment">// base structure</span>
    <span class="keywordtype">char</span> dial[ MAX_SIZE_DIAL ];     <span class="comment">// parameter &#39;dial&#39;</span>
    <span class="keywordtype">int</span> qty;                        <span class="comment">// parameter &#39;qty&#39;</span>
} DIAL_T;
    
<span class="keyword">typedef</span> <span class="keyword">struct</span>
{
    <a class="code" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> evt;                   <span class="comment">// base structure</span>
    <span class="keywordtype">int</span> volume;                     <span class="comment">// parameter &#39;volume&#39;</span>
    <span class="keywordtype">int</span> baud_rate;                  <span class="comment">// parameter &#39;baud_rate&#39;</span>
    <span class="keywordtype">char</span> name[ MAX_SIZE_NAME ];     <span class="comment">// parameter &#39;name&#39;</span>
    <span class="keywordtype">int</span> iloop;                      <span class="comment">// parameter &#39;iloop&#39;</span>
} SETUP_T;

<span class="comment">// declares the storage memory of event pool</span>
<span class="keyword">static</span> rkhui8_t ep0sto[ SIZEOF_EP0STO ],
                ep1sto[ SIZEOF_EP1STO ],
                ep2sto[ SIZEOF_EP2STO ];

...
rkh_epool_register( ep0sto, SIZEOF_EP0STO, SIZEOF_EP0_BLOCK  );
<a class="code" href="rkh_8h.html#aafd0b47b3a410c6b89e499b39a28f874" title="Registers a new event pool into the event pool list.">rkh_epool_register</a>( ep1sto, SIZEOF_EP1STO, SIZEOF_EP1_BLOCK  );
<a class="code" href="rkh_8h.html#aafd0b47b3a410c6b89e499b39a28f874" title="Registers a new event pool into the event pool list.">rkh_epool_register</a>( ep2sto, SIZEOF_EP2STO, SIZEOF_EP2_BLOCK  );
...
</pre></div><h3><a class="anchor" id="qref7_2"></a>
Allocating events</h3>
<div class="fragment"><pre class="fragment">(1) <span class="keyword">typedef</span> <span class="keyword">struct</span>
    {
        <a class="code" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> evt;                   <span class="comment">// base structure</span>
        <span class="keywordtype">char</span> dial[ MAX_SIZE_DIAL ];     <span class="comment">// parameter &#39;dial&#39;</span>
        <span class="keywordtype">int</span> qty;                        <span class="comment">// parameter &#39;qty&#39;</span>
    } DIAL_T;

(2) <span class="keyword">typedef</span> <span class="keyword">struct</span>
    {
        <a class="code" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> evt;                   <span class="comment">// base structure</span>
        <span class="keywordtype">int</span> volume;                     <span class="comment">// parameter &#39;volume&#39;</span>
        <span class="keywordtype">int</span> baud_rate;                  <span class="comment">// parameter &#39;baud_rate&#39;</span>
        <span class="keywordtype">char</span> name[ MAX_SIZE_NAME ];     <span class="comment">// parameter &#39;name&#39;</span>
        <span class="keywordtype">int</span> iloop;                      <span class="comment">// parameter &#39;iloop&#39;</span>
    } SETUP_T;

    <span class="keyword">typedef</span> <span class="keyword">struct</span>
    {
        <a class="code" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> evt;
        <span class="keywordtype">int</span> timerno;
    } TOUT_T;

(3) <span class="keyword">static</span> <a class="code" href="rkh_8h.html#ac2d1fc13a6b019e7967db720d72dfcd8" title="This macro declares and initializes the event structure e with es signal and establishes it as one st...">RKH_DCLR_STATIC_EVENT</a>( offh, OFFHOOK );
(4) <span class="keyword">static</span> TOUT_T tout;

...

(5) <a class="code" href="rkh_8h.html#a1e1ded09fc7d2c30b33a74ebccf1bc3e" title="This macro initialize an event e with es signal and establishes it as one static event.">RKH_SET_STATIC_EVENT</a>( &amp;tout, TIMEOUT );
(6) DIAL_T *de = <a class="code" href="rkh_8h.html#a66808180348a0a822a0fa46328b7f7d9" title="This macro dynamically creates a new event of type et with its signal.">RKH_ALLOC_EVENT</a>( DIAL_T, DIALED );
(7) SETUP_T *se = <a class="code" href="rkh_8h.html#a66808180348a0a822a0fa46328b7f7d9" title="This macro dynamically creates a new event of type et with its signal.">RKH_ALLOC_EVENT</a>( SETUP_T, SET_CONFIG );
(8) se-&gt;volume = 0;
    se-&gt;baud_rate = DEFAULT_BAUD_RATE;
    se-&gt;iloop = 2;
</pre></div><p>Explanation</p>
<ul>
<li>(1-2) As mentioned before, implementing the single inheritance in C is very simply by literally embedding the base structure, <a class="el" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> in this case, as the first member of the derived structure, <code>DIAL_T</code> and <code>SETUP_T</code>. </li>
<li>(3) The <code>OFFHOOK</code> event never changes, so it can be statically allocated just once. This event is declared as const, which means that it can be placed in ROM. The initializer list for this event consists of the signal <code>OFFHOOK</code> followed by zero. This zero informs the RKH framework that this event is <em>static</em> and should never be recycled to an event pool. </li>
<li>(4) The <code>TIMEOUT( timerno )</code> event is an example of an event with changing parameters. In general, such an event cannot be allocated in ROM like the <code>OFFHOOK</code> event because it can change. </li>
<li>(5) This macro set the event <code>TIMEOUT( timerno )</code> with <code>TIMEOUT</code> signal and establishes it as one <em>static event</em>. </li>
<li>(6-7) The <a class="el" href="rkh_8h.html#a66808180348a0a822a0fa46328b7f7d9" title="This macro dynamically creates a new event of type et with its signal.">RKH_ALLOC_EVENT()</a> macro dynamically creates a new instances events of type <code>DIAL_T</code> and <code>SETUP_T</code> with <code>DIALED</code> and <code>SET_CONFIG</code> signals. These events are represented like this: <code>DIALED( dial, qty )</code> and <code> SET_CONFIG( volume, baud_rate, name, iloop )</code> This macro returns a pointer to the event already cast to the required event type. </li>
<li>(8) The <code>volume</code>, <code>baud_rate</code>, and <code>iloop</code> parameters of the event are assigned.</li>
</ul>
<p>Just one another example that it could be used to easily debug an application with static events.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keyword">struct</span>
{
    <a class="code" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> evt;
<span class="preprocessor">#if SYSEVT_DEBUG == 1</span>
<span class="preprocessor"></span>    <span class="keywordtype">char</span> *name;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>} SYSEVT_T;

<span class="preprocessor">#if SYSEVT_DEBUG == 1</span>
<span class="preprocessor"></span><span class="preprocessor">    #define mkse( e, n )        { { (e), 0, 0 }, (n) }</span>
<span class="preprocessor"></span><span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">    #define mkse( e, n )        { { (e), 0, 0 } }</span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="keyword">static</span> <span class="keyword">const</span> SYSEVT_T sysevts[] =
{
    mkse( OFFHOOK,  <span class="stringliteral">&quot;offhook&quot;</span> ),
    mkse( ONHOOK,   <span class="stringliteral">&quot;onhook&quot;</span> ),
    mkse( POLREV,   <span class="stringliteral">&quot;polarity reversal&quot;</span> ),
    mkse( BTONE,    <span class="stringliteral">&quot;billing tone&quot;</span> ),
    ...
};
</pre></div><h3><a class="anchor" id="qref7_3"></a>
Posting events</h3>
<p>The RKH framework supports one type of asynchronous event exchange: the simple mechanism of direct event posting supported through the functions <a class="el" href="rkh_8h.html#ac11aaa38aefb41673027b1baa44fdd3b" title="Send an event to a state machine application through a queue using the FIFO policy. A message is a pointer size variable and its use is application specific.">rkh_sma_post_fifo()</a> and <a class="el" href="rkh_8h.html#a8293c298ff040cc8277e6ded413f8037" title="Send an event to a state machine application through a queue using the LIFO policy. A message is a pointer size variable and its use is application specific.">rkh_sma_post_lifo()</a>, when the producer of an event directly posts the event to the event queue of the consumer SMA (active object).</p>
<div class="fragment"><pre class="fragment">(1) <span class="keyword">static</span> <a class="code" href="rkh_8h.html#ac2d1fc13a6b019e7967db720d72dfcd8" title="This macro declares and initializes the event structure e with es signal and establishes it as one st...">RKH_DCLR_STATIC_EVENT</a>( eterm, TERM );
...

(2) <a class="code" href="rkh_8h.html#ac11aaa38aefb41673027b1baa44fdd3b" title="Send an event to a state machine application through a queue using the FIFO policy. A message is a pointer size variable and its use is application specific.">rkh_sma_post_fifo</a>( manager, &amp;eterm );
</pre></div><ul>
<li>(1) Declares and initializes the event <em>eterm</em> with <em>TERM</em> signal and establishes it as one static event. </li>
<li>(2) The <code>eterm</code> event is sent directly to the <code>manager</code> SMA.</li>
</ul>
<div class="fragment"><pre class="fragment">...
(1) mye = <a class="code" href="rkh_8h.html#a66808180348a0a822a0fa46328b7f7d9" title="This macro dynamically creates a new event of type et with its signal.">RKH_ALLOC_EVENT</a>( MYEVT_T, kbmap( c ) );
(2) mye-&gt;ts = ( rkhui16_t )rand();
(3) <a class="code" href="rkh_8h.html#ac11aaa38aefb41673027b1baa44fdd3b" title="Send an event to a state machine application through a queue using the FIFO policy. A message is a pointer size variable and its use is application specific.">rkh_sma_post_fifo</a>( my, ( <a class="code" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a>* )mye );
</pre></div><ul>
<li>(1) Dynamically creates a new event <code>mye</code> of type <em>MYEVT_T</em> with the signal returned from the kbmap() function. </li>
<li>(2) Use the extended members of the event <code>mye</code>. </li>
<li>(3) The <code>mye</code> event is sent directly to the <code>my</code> SMA.</li>
</ul>
<h3><a class="anchor" id="qref7_4"></a>
Recycling dynamic events</h3>
<p>If the system make use of dynamic events facility after the processing, you must not forget to call the RKH garbage collector, because now RKH is no longer in charge of event processing and you are solely responsible for not leaking the event. The garbage collector actually recycles the event only when it determines that the event is no longer referenced. The following listing illustrates how and when to invoke <a class="el" href="rkh_8h.html#a5a62e6121174abd89d8a77b9ebef0736" title="Recycle a dynamic event.">RKH_GC()</a> macro to recycle "dynamic" events.</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> 
    <a class="code" href="rkh_8h.html#a6b8f47b2f288dd0cf2c8b44dd062d509" title="RKH framework is started.">rkh_enter</a>( <span class="keywordtype">void</span> )
    {
        rkhui8_t prio;
        <a class="code" href="struct_r_k_h_s_m_a___t.html" title="Describes the SMA (active object in UML).">RKHSMA_T</a> *sma;
        <a class="code" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> *e;

        <a class="code" href="rkh_8h.html#a8e824db08ba7430b74762a487804812b" title="This hook function is called just before the RKH takes over control of the application.">rkh_hk_start</a>();
        <a class="code" href="rkhtrc_8h.html#adc7d4420a30cd0208f897ec2bd9a0234">RKH_TRCR_RKH_EN</a>();

        FOREVER
        {
            <a class="code" href="rkhitl_8h.html#a5e8366e36b0290e15bd75988390cc760">RKH_DIS_INTERRUPT</a>();
            <span class="keywordflow">if</span>( <a class="code" href="rkhrdy_8h.html#a8a93c5eb6c2a9ad46bf37cc21a4f5eea" title="This macro evaluates to TRUE if any SMA is ready to run.">rkh_rdy_isnot_empty</a>( rkhrg ) )
            {
                <a class="code" href="rkhrdy_8h.html#ab5ba4ef6e05e88daeff78572d9f7cab6" title="Finding the highest priority SMA ready to run.">rkh_rdy_findh</a>( rkhrg, prio );
                sma = <a class="code" href="rkh_8h.html#a3a9318a6a79d7b808df2f75351ba0286" title="Priority arranged table of registered SMA.">rkh_sptbl</a>[ prio ];
                <a class="code" href="rkhitl_8h.html#aed1d3d5ccbd9ff2fb694e809e494759d">RKH_ENA_INTERRUPT</a>();

(1)             e = <a class="code" href="rkh_8h.html#af8993801a4f995bafb8870cde439cfb7" title="Get an event from the event queue of an state machine application. The events received are pointer si...">rkh_sma_get</a>( sma );
(2)             <a class="code" href="rkh_8h.html#ae56c0173d50898325d8e64eac816399b" title="Executes a state machine in a non-preemtive model.">rkh_dispatch</a>( sma, e );
(3)             <a class="code" href="rkh_8h.html#a5a62e6121174abd89d8a77b9ebef0736" title="Recycle a dynamic event.">RKH_GC</a>( e );
            }
            <span class="keywordflow">else</span> 
            <span class="comment">//</span>
            <span class="comment">// rkh_hk_idle() must be called with interrupts DISABLED because the </span>
            <span class="comment">// determination of the idle condition (no events in the queues) can </span>
            <span class="comment">// change at any time by an interrupt posting events to a queue. The </span>
            <span class="comment">// rkh_hk_idle() MUST enable interrups internally, perhaps at the </span>
            <span class="comment">// same time as putting the CPU into a power-saving mode.</span>
            <span class="comment">//          </span>
                <a class="code" href="rkh_8h.html#a5edbaf8597b0b92d05d80dfddd891d52" title="An idle hook function will only get executed (with interrupts LOCKED) when there are no SMAs of highe...">rkh_hk_idle</a>();
        }
    }
</pre></div><ul>
<li>(1) An event <code>e</code> is get from the SMA queue with the highest priority. </li>
<li>(2) The event <code>e</code> is dispatched to the current SMA. </li>
<li>(2) Thus, the event <code>e</code> is passed to the RKH garbage collector for recycling. As described above, the <a class="el" href="rkh_8h.html#a5a62e6121174abd89d8a77b9ebef0736" title="Recycle a dynamic event.">RKH_GC()</a> macro actually recycles the wvent only when it determines that the event is no longer referenced.</li>
</ul>
<h3><a class="anchor" id="qref7_5"></a>
Customization</h3>
<p>Each RKH application must have its own configuration file, called <b><a class="el" href="rkhcfg_8h.html" title="RKH user configuration.">rkhcfg.h</a></b>. This file adapts and configures RKH by means of compiler definitions and macros allowing to restrict the resources consumed by RKH. Adjusting this definitions allows to reduce the ROM and RAM consumption, and to enhance the system performance in a substantial manner. The <b><a class="el" href="rkhcfg_8h.html" title="RKH user configuration.">rkhcfg.h</a></b> shows the general layout of the configuration file. Use the following macros to reduce the memory taken by state machine structure. See <a class="el" href="cfg.html">Configuration</a> section for more information.</p>
<ul>
<li><b>RKH_EN_DYNAMIC_EVENT:</b> <br/>
 <p>If the dynamic event support (see <a class="el" href="rkhcfg_8h.html#aaec7e4da63ca0f9d4d45ae22fa8d250e">RKH_EN_DYNAMIC_EVENT</a>) is set to 1, RKH allows to use event with parameters, defer/recall, allocating and recycling dynamic events, among other features. </p>
</li>
<li><b>RKH_MAX_EPOOL:</b> <br/>
 <p>If the dynamic event support is enabled (see <a class="el" href="rkhcfg_8h.html#aaec7e4da63ca0f9d4d45ae22fa8d250e">RKH_EN_DYNAMIC_EVENT</a>) then the <a class="el" href="rkhcfg_8h.html#a5e198fc8d2c0fefbca08d0f2231d37e1">RKH_MAX_EPOOL</a> can be used to specify the maximum number of fixed-size memory block pools to be used by the application (can be a number in the range [0..256]). Note that a value of 0 will completely suppress the memory pool services. </p>
</li>
<li><b>RKH_SIZEOF_EVENT:</b> <br/>
 <p>Specify the size of the event signal. The valid values [in bits] are 8, 16 or 32. Default is 8. The higher the signal size, the higher the event structure size and therefore more memory consumption. See <a class="el" href="rkhevt_8h.html#a8a78cec3a9dfc2336bd084c221e15e10">RKHE_T</a> data type. </p>
</li>
<li><b>RKH_SIZEOF_ESIZE:</b> <br/>
 <p>Specify the data type of event size. The valid values [in bits] are 8, 16 or 32. Default is 8. See <a class="el" href="rkhevt_8h.html#a97327b17e4be27368f9f6ad66ea1d785">RKHES_T</a>, <a class="el" href="rkh_8h.html#aafd0b47b3a410c6b89e499b39a28f874" title="Registers a new event pool into the event pool list.">rkh_epool_register()</a>, and <a class="el" href="rkh_8h.html#a66808180348a0a822a0fa46328b7f7d9" title="This macro dynamically creates a new event of type et with its signal.">RKH_ALLOC_EVENT()</a>. </p>
</li>
<li><b>RKH_EN_NATIVE_DYN_EVENT:</b> <br/>
 <p>If the <a class="el" href="rkhcfg_8h.html#a51733bf9ffb1aceb18d950fd4cce5a93">RKH_EN_NATIVE_DYN_EVENT</a> is set to 1 and the native fixed-size memory block facility is enabled (see <a class="el" href="rkhcfg_8h.html#ab893f2b2e3aba36212400404842235f9">RKH_MP_EN</a>) then RKH will include its own implementation of dynamic memory management. When <a class="el" href="rkhcfg_8h.html#a51733bf9ffb1aceb18d950fd4cce5a93">RKH_EN_NATIVE_DYN_EVENT</a> is enabled RKH also will automatically define RKH_DYNE_TYPE, <a class="el" href="rkhitl_8h.html#a4b5aee3c127ac9c2618c2452b6bd65b2" title="Encapsulates the creation of a event pool.">RKH_DYNE_INIT()</a>, <a class="el" href="rkhitl_8h.html#ae5c52c17f40c4119b0aebffacf4ecb04" title="Encapsulates how RKH should obtain the block size of pool.">RKH_DYNE_GET_ESIZE()</a>, <a class="el" href="rkhitl_8h.html#a90dcc5b49faff4d8dde016f8aea160fa" title="Encapsulates how RKH should obtain an event e from the event pool mp.">RKH_DYNE_GET()</a>, and <a class="el" href="rkhitl_8h.html#a3d3e4448b8b4fdaef1501bf2723b0cde" title="Encapsulates how RKH should return an event e to the event pool mp.">RKH_DYNE_PUT()</a>. </p>
</li>
<li><b>RKH_DYNE_TYPE:</b> <br/>
 <p>The fixed-size memory block can be implemented with a RTOS/OS service provided to that. But it's also possible to use the native RKH fixed-size memory block <a class="el" href="struct_r_k_h_m_p___t.html" title="Defines the data structure used to memory block pool facility.">RKHMP_T</a> type if the underlying RTOS/OS does not provide an adequate support. </p>
</li>
<li><b>RKH_DYNE_INIT:</b> <br/>
 <p>Platform-dependent macro. Typically, must be define it in the specific port file (rkhport.h).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>pointer to previously allocated memory pool structure. </td></tr>
    <tr><td class="paramname">sstart</td><td>storage start. Pointer to memory from which memory blocks are allocated. </td></tr>
    <tr><td class="paramname">ssize,:</td><td>storage size. Size of the memory pool storage in bytes. </td></tr>
    <tr><td class="paramname">esize</td><td>event size. This number determines the size of each memory block in the pool. </td></tr>
  </table>
  </dd>
</dl>
</li>
<li><b>RKH_DYNE_GET_ESIZE:</b> <br/>
 <p>Platform-dependent macro. Typically, must be define it in the specific port file (rkhport.h).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>pointer to previously allocated memory pool structure. </td></tr>
  </table>
  </dd>
</dl>
</li>
<li><b>RKH_DYNE_GET:</b> <br/>
 <p>Platform-dependent macro. Typically, must be define it in the specific port file (rkhport.h).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>pointer to previously allocated memory pool structure. </td></tr>
    <tr><td class="paramname">e</td><td>pointer to a new event or NULL if the pool runs out of blocks. </td></tr>
  </table>
  </dd>
</dl>
</li>
<li><b>RKH_DYNE_PUT:</b> <br/>
 <p>Platform-dependent macro. Typically, must be define it in the specific port file (rkhport.h).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>pointer to previously allocated memory pool structure. </td></tr>
    <tr><td class="paramname">e</td><td>pointer to the returned event. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<hr/>
 <h2><a class="anchor" id="qref13"></a>
Preprocessing events before of dispatch it</h2>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<p>Before sending the arrived event to state machine, it can be previously processed using the event preprocessor function. The RKH framework provides optional event preprocessor action, which are associated with states rather than transitions, as in a Moore automaton. This action takes the state machine pointer and the event pointer as arguments. This argument is optional, thus it could be eliminated in compile-time by means of RKH_SMA_EN_PPRO_ARG_SMA.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This callback is referenced from <a class="el" href="rkh_8h.html#acc24b2221cd374e66732a09fb24b56ce" title="This macro creates a composite state.">RKH_CREATE_COMP_STATE()</a> and <a class="el" href="rkh_8h.html#a3567a7f91a5dc5759747dc8528357b44" title="This macro creates a basic state.">RKH_CREATE_BASIC_STATE()</a> macros. </dd></dl>
<p>The next listing shows an example of the event preprocessor action implementation.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="rkhevt_8h.html#a8a78cec3a9dfc2336bd084c221e15e10">RKHE_T</a> 
preprocess_keys( <span class="keyword">const</span> <span class="keyword">struct</span> rkh_t *sma, <a class="code" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> *pe )
{
    printf( <span class="stringliteral">&quot;From state machine \&quot;%s\&quot;\n&quot;</span>, rkh_get_sm_name( sma ) );
    <span class="keywordflow">if</span>( pe-&gt;<a class="code" href="struct_r_k_h_e_v_t___t.html#ace79af9a2276cf72d7accf7f8f2c957e">e</a> &gt;= 0 &amp;&amp; pe-&gt;<a class="code" href="struct_r_k_h_e_v_t___t.html#ace79af9a2276cf72d7accf7f8f2c957e">e</a> &lt;= 9 )
        <span class="keywordflow">return</span> DECIMAL;
    <span class="keywordflow">if</span>( pe-&gt;<a class="code" href="struct_r_k_h_e_v_t___t.html#ace79af9a2276cf72d7accf7f8f2c957e">e</a> == <span class="charliteral">&#39;.&#39;</span> )
        <span class="keywordflow">return</span> POINT;
    <span class="keywordflow">else</span>
        <span class="keywordflow">return</span> pe-&gt;<a class="code" href="struct_r_k_h_e_v_t___t.html#ace79af9a2276cf72d7accf7f8f2c957e">e</a>;
}
</pre></div><p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<hr/>
 <h2><a class="anchor" id="qref8"></a>
Deferring and recalling events</h2>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<p>Event deferral comes in very handy when an event arrives in a particularly inconvenient moment but can be deferred for some later time, when the system is in a much better position to handle the event. RKH supports very efficient event deferring and recalling mechanisms. RKH provides a simple function call to defer an event to a given separate event queue, <a class="el" href="rkh_8h.html#a994172cec235f0bc4aa32f72e5497621" title="Defer an event to a given separate event queue.">rkh_defer()</a>. Also, offers another simple function to recall a deferred event, <a class="el" href="rkh_8h.html#a1699d08d464d2c77bd9aee5e4e55568e" title="Recall a deferred event from a given event queue.">rkh_recall()</a>.</p>
<p>An active object uses <code>rkh_defer( qd, evt )</code> to defer an event <em>evt</em> to the event queue <em>qd</em>. RKH correctly accounts for another outstanding reference to the event and will not recycle the event at the end of the RTC step. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>For memory efficiency and best performance the deferred event queue, STORE ONLY POINTERS to events, not the whole event objects. An active object can use multiple event queues to defer events of different kinds. The assertion inside it guarantee that operation is valid, so is not necessary to check the value returned from it.</dd></dl>
<p>Later, the active object might recall one event at a time from the event queue by means of <code>rkh_recall( qdd, qds )</code> function. Recalling an event means that it is removed from the deferred event queue <em>qds</em> and posted (LIFO) to the event queue of the active object <em>qdd</em>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>For memory efficiency and best performance the destination event queue, STORE ONLY POINTERS to events, not the whole event objects. The pointer to the recalled event to the caller, or NULL if no event has been recalled.</dd></dl>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<hr/>
 <h2><a class="anchor" id="qref9"></a>
Using assertions</h2>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<p>The assertions (<code><a class="el" href="rkhassert_8h.html#a44e0d6b7a49a3b03d45b88111391031d" title="The RKHASSERT() macro is used to check expressions that ought to be true as long as the program is ru...">RKHASSERT()</a></code> macro) are used to check expressions that ought to be true as long as the program is running correctly. It is a convenient way to insert sanity checks. A number of philosophies can be employed when deciding where to use an <code><a class="el" href="rkhassert_8h.html#a44e0d6b7a49a3b03d45b88111391031d" title="The RKHASSERT() macro is used to check expressions that ought to be true as long as the program is ru...">RKHASSERT()</a></code> macro. Broadly speaking, the assertions only serve the purposes of catching bugs and helping documentation. Helping to document the code means that the statements inside the assertion tell the reader something he might not already know.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The preprocessor switch RKH_ASSERT_EN disables checking assertions. In particular macros <a class="el" href="rkhassert_8h.html#a44e0d6b7a49a3b03d45b88111391031d" title="The RKHASSERT() macro is used to check expressions that ought to be true as long as the program is ru...">RKHASSERT()</a>, <a class="el" href="rkhassert_8h.html#adc8b87efd3c9461ef70cc0de459e35d2" title="This macro checks the precondition.">RKHREQUIRE()</a>, <a class="el" href="rkhassert_8h.html#a2b0f37321a4da4d6d7b7274b8b03aa8c" title="This macro checks the postcondition.">RKHENSURE()</a>, <a class="el" href="rkhassert_8h.html#a5a7aaadc644dd712104fee341388c3fa" title="This macro is used to check a loop invariant.">RKHINVARIANT()</a>, and <a class="el" href="rkhassert_8h.html#af9b44e64825198cb862651d035b7d2b2" title="Assertion that always calls the rkh_assert() callback if ever executed.">RKHERROR()</a> do NOT evaluate the test condition passed as the argument to these macros. One notable exception is the macro <a class="el" href="rkhassert_8h.html#a859d6d0ca084abb8e273c0c0d5c79c35" title="General purpose assertion that ALWAYS evaluates the exp argument and calls the RKHASSERT() macro if t...">RKHALLEGE()</a>, that still evaluates the test condition, but does not report assertion failures when the switch RKH_ASSERT_EN is defined.</dd></dl>
<p>Example of use: </p>
<div class="fragment"><pre class="fragment">    ...
    some_function( <span class="keyword">const</span> <span class="keywordtype">char</span> *p, <span class="keywordtype">int</span> size )
    {
        <a class="code" href="rkhassert_8h.html#a44e0d6b7a49a3b03d45b88111391031d" title="The RKHASSERT() macro is used to check expressions that ought to be true as long as the program is ru...">RKHASSERT</a>(  p != ( <span class="keyword">const</span> <span class="keywordtype">char</span>* )0 &amp;&amp;
                    size &gt; 0  &amp;&amp; size &lt; MAX_SIZE );
        ...
    }
</pre></div><p>If the expression evaluates to FALSE (0), the function <a class="el" href="rkhassert_8h.html#ad3c2370571718a2d3fc76b9bf9850cd5" title="Callback invoked in case the condition passed to RKHASSERT(), RKHREQUIRE(), RKHENSURE(), RKHERROR(), or RKHALLEGE() evaluates to FALSE.">rkh_assert()</a> will be invoked, typically halting the program in some way and storing or reporting the error code. Once the <a class="el" href="rkhassert_8h.html#ad3c2370571718a2d3fc76b9bf9850cd5" title="Callback invoked in case the condition passed to RKHASSERT(), RKHREQUIRE(), RKHENSURE(), RKHERROR(), or RKHALLEGE() evaluates to FALSE.">rkh_assert()</a> callback has stored or reported the error, it must decide on the system's next action. One option is:</p>
<ol type="1">
<li>disable general interrupt</li>
<li>stores or send detected error (could be use a trace facility)</li>
<li>trigger a software reset</li>
</ol>
<p>The policy chooses will be largely determined by the nature of product. If the system is running with a source level debugger, place a breakpoint within. Another option is to trigger a software reset and attempt to run the system again.</p>
<p>Also a unique identifier that can be reported from the field, easing the investigation of the problem. Therefore, the error code could be composed of the software version number, file number (.c file), line number of assertion, and other information. A number is easier to fill in on a report form and easier to store in NVRAM.</p>
<p>The following listing shows a illustrative example for VC8 IDE:</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> 
    <a class="code" href="rkhassert_8h.html#ad3c2370571718a2d3fc76b9bf9850cd5" title="Callback invoked in case the condition passed to RKHASSERT(), RKHREQUIRE(), RKHENSURE(), RKHERROR(), or RKHALLEGE() evaluates to FALSE.">rkh_assert</a>( RKHROM <span class="keywordtype">char</span> * <span class="keyword">const</span> file, <span class="keywordtype">int</span> line )
    {
        printf( <span class="stringliteral">&quot;RKHASSERT: [%d] line from %s file\n&quot;</span>, line, file );
        __debugbreak();
    }
</pre></div> <p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<hr/>
 <h2><a class="anchor" id="qref10"></a>
Debugging an application based on RKH's state machines</h2>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<p>Please refer to <a class="el" href="dbg.html">Tracing tool</a> section.</p>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<hr/>
 <h2><a class="anchor" id="qref15"></a>
Initializing a state machine and dispatching events</h2>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a></p>
<p>The following listing shows an very simple example of the main() function implementation and demostrates how to use the RKH API.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>See <a class="el" href="_usage.html">Representing a state machine: step by step</a> section for more information about this.</dd></dl>
<div class="fragment"><pre class="fragment">    ...
    <span class="keyword">typedef</span> <span class="keyword">struct</span>
    {
        <a class="code" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> event;
        rkhuint16 ts;
    } MYEVT_T;

    <span class="keyword">static</span> MYEVT_T mye;
    ...

    <span class="keywordtype">int</span>
    main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[] )
    {
        <span class="keywordtype">int</span> c;

(1)     <a class="code" href="rkh_8h.html#a01e6ed5f8d81d1e3ec5bf32d44a4bab6" title="Open the tracing session.">rkh_trc_open</a>();
(2)     <a class="code" href="rkh_8h.html#a348c60d5a5c6b1492ca55648e9aeeaf6" title="Initializes the RKH framework.">rkh_init</a>();

        srand( ( <span class="keywordtype">unsigned</span> )time( NULL ) );
(3)     <a class="code" href="rkh_8h.html#a395d701b816dd11bdd9835483607ae5f" title="Inits a previously created state machine calling its initializing action.">rkh_init_hsm</a>( my );

(4)     FOREVER
        {
(5)         c = mygetch();
            
            <span class="keywordflow">if</span>( c == <span class="charliteral">&#39;p&#39;</span> )
(6)             <a class="code" href="rkh_8h.html#a40281729b441d54e4118a6809540bb2f" title="Platform-dependent macro flushing the trace stream.">rkh_trc_flush</a>();
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( c == ESC )
            {
(7)             <a class="code" href="rkh_8h.html#ae56c0173d50898325d8e64eac816399b" title="Executes a state machine in a non-preemtive model.">rkh_dispatch</a>( my, &amp;term );
                <span class="keywordflow">break</span>;
            }
            <span class="keywordflow">else</span>
            {
(8)             mye = <a class="code" href="rkh_8h.html#a66808180348a0a822a0fa46328b7f7d9" title="This macro dynamically creates a new event of type et with its signal.">RKH_ALLOC_EVENT</a>( MYEVT_T, kbmap( c ) );
(9)             mye-&gt;ts = ( rkhui16_t )rand();
(10)            <a class="code" href="rkh_8h.html#ae56c0173d50898325d8e64eac816399b" title="Executes a state machine in a non-preemtive model.">rkh_dispatch</a>( my, ( <a class="code" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a>* )mye );
            }
        }

(11)    <a class="code" href="rkh_8h.html#a82ea03425018b8a70571b3499b70e8d3" title="Close the tracing session.">rkh_trc_close</a>();
(12)    <a class="code" href="rkh_8h.html#ab18447f196fdd82c3d46617dff71a44c" title="Exit the RKH framework.">rkh_exit</a>();
    }
</pre></div><ul>
<li>(1) Open the trace session. </li>
<li>(2) Initialize the framework RKH. </li>
<li>(3) Initialize the <code>my</code> state machine. RKH invokes the defined init action. </li>
<li>(4) This is the event loop of the framework RKH. </li>
<li>(5) Gets key pressed from the standard input. </li>
<li>(6) Flush the trace stream. </li>
<li>(7) Send the <code>term</code> event to <code>my</code> state machine to terminate. After that, terminates the program. </li>
<li>(8) Allocates an event of <code>MYEVT_T</code> type (derived from <a class="el" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a>) to store the key pressed. </li>
<li>(9) The event has associated parameters that convey a random number. </li>
<li>(10) The <code>mye</code> event is dispatched to <code>my</code> state machine. Events with parameters, such as the MYEVT_T, require explicit casting from the generic base structure <a class="el" href="struct_r_k_h_e_v_t___t.html" title="Represents events without parameters.">RKHEVT_T</a> to the specific derived structure MYEVT_T. </li>
<li>(11-12) Close the trace session and terminates the program.</li>
</ul>
<hr/>
 <h2><a class="anchor" id="qref18"></a>
Using RKH software timers</h2>
<p><br/>
 Prev: <a class="el" href="qref.html">Quick reference</a> <br/>
</p>
<p>RKH software timers enables to execute application C functions and/or send an event to application state machine (SMA) at specific intervals of time. It can also set an application timer to expire only once. This type of timer is called a one-shot timer, while repeating interval timers are called periodic timers. Each application timer is a public resource. Time intervals are measured by periodic timer interrupts. Each timer interrupt is called a timer-tick. The actual time between timer-ticks is specified by the application. On the other hand, application timers execute in the order in which they become active. </p>
<p>This section includes:</p>
<ul>
<li><a class="el" href="qref.html#qref18_1">Declaring, and initializing a timer</a></li>
<li><a class="el" href="qref.html#qref18_2">Start and stop timers</a></li>
<li><a class="el" href="qref.html#qref18_3">Customization</a></li>
</ul>
<h3><a class="anchor" id="qref18_1"></a>
Declaring, and initializing a timer</h3>
<div class="fragment"><pre class="fragment">...
(1) <span class="keyword">static</span> <a class="code" href="struct_r_k_h_t___t.html" title="Defines the data structure used to maintain information that allows the timer-handling facility to up...">RKHT_T</a> tlayer;

    void
(2) tlayer_tout( <span class="keywordtype">void</span> *t )
    {
        (void)t;
        close_layer();
    }

(3) <a class="code" href="rkhtim_8h.html#aa8521ccd9ef5907d8d8c6ee30caf2f14" title="Initializes the previously allocated timer structure RKHT_T.">rkh_tim_init</a>(   &amp;tlayer, 
(4)                 TOUT, 
(5)                 tlayer_tout );
...
</pre></div><p>Explanation</p>
<ul>
<li>(1) Declares and allocates the <code>tlayer</code> timer. </li>
<li>(2) Defines <code>tlayer_tout()</code> hook function, which is calls at the <code>tlayer</code> expiration. </li>
<li>(3) Initializes the <code>tlayer</code> timer. </li>
<li>(4) <code>TOUT</code> is the signal of the event to be directly posted (using the FIFO policy) into the event queue of the target agreed state machine application at the timer expiration. </li>
<li>(5) Registers <code>tlayer_tout()</code> hook function.</li>
</ul>
<h3><a class="anchor" id="qref18_2"></a>
Start and stop timers</h3>
<div class="fragment"><pre class="fragment">(1) #define TPWR_TICK           100
(2) #define TKEY_TICK           100
...
(3) <span class="keyword">static</span> <a class="code" href="struct_r_k_h_t___t.html" title="Defines the data structure used to maintain information that allows the timer-handling facility to up...">RKHT_T</a>   tpwr,
(4)                 tkey;

(5) <a class="code" href="rkhtim_8h.html#aa8521ccd9ef5907d8d8c6ee30caf2f14" title="Initializes the previously allocated timer structure RKHT_T.">rkh_tim_init</a>( &amp;tpwr, TPWR, NULL );
(6) <a class="code" href="rkhtim_8h.html#aa8521ccd9ef5907d8d8c6ee30caf2f14" title="Initializes the previously allocated timer structure RKHT_T.">rkh_tim_init</a>( &amp;tkey, TKEY, NULL );
...
(7) <a class="code" href="rkhtim_8h.html#a0afe1937501e53a2d04fcd751231d773" title="Start a timer as one-shot timer.">rkh_tim_oneshot</a>( &amp;tpwr, pwr, TPWR_TICK );
(8) <a class="code" href="rkhtim_8h.html#adf1f28b6cbb771c31e2511d0f731848f" title="Start a timer as periodic timer.">rkh_tim_periodic</a>( &amp;tkey, pwr, TKEY_TICK, TKEY_TICK/4 );
...
(9) <a class="code" href="rkhtim_8h.html#a8d2cd3cb02bf19089fd56b89fd17fcb5" title="Stops a running timer. This operation stops a timer by removing the currently running timer from the ...">rkh_tim_stop</a>( &amp;tkey );
...
(10)<a class="code" href="rkhtim_8h.html#a7784197869fd89d32ec363eb6d3cfb66" title="Restart a timer with a new number of ticks.">rkh_tim_restart</a>( &amp;tpwr, TPWR_TICK * 2 );
</pre></div><p>Explanation</p>
<ul>
<li>(1-2) Defines the number of ticks for timer expiration. </li>
<li>(3-4) Declares and allocates the <code>tpwr</code>, and <code>tkey</code> timers. </li>
<li>(5-6) Initializes the <code>tpwr</code>, and <code>tkey</code> timers. </li>
<li>(7) Starts <code>tpwr</code> timer as one-shot timer, which posts the signal <code>TPWR</code> to <code>pwr</code> state machine application after TPWR_TICK timer-ticks. </li>
<li>(8) Starts <code>tkey</code> timer as periodic timer, which posts the signal <code>TKEY</code> to <code>pwr</code> state machine application after TKEY_TICK timer-ticks initially and then after every TKEY_TICK/4 timer-ticks. </li>
<li>(9) Stops <code>tkey</code> timer. </li>
<li>(10) Restarts <code>tpwr</code> timer with a new number of ticks.</li>
</ul>
<h3><a class="anchor" id="qref18_3"></a>
Customization</h3>
<p>Each RKH application must have its own configuration file, called <b><a class="el" href="rkhcfg_8h.html" title="RKH user configuration.">rkhcfg.h</a></b>. This file adapts and configures RKH by means of compiler definitions and macros allowing to restrict the resources consumed by RKH. Adjusting this definitions allows to reduce the ROM and RAM consumption, and to enhance the system performance in a substantial manner. The <b><a class="el" href="rkhcfg_8h.html" title="RKH user configuration.">rkhcfg.h</a></b> shows the general layout of the configuration file. Use the following macros to reduce the memory taken by state machine structure. See <a class="el" href="cfg.html">Configuration</a> section for more information.</p>
<ul>
<li><b>RKH_TIM_EN:</b> <br/>
 <p>If the <a class="el" href="rkhcfg_8h.html#a3bea0299225d8085abd37d2de0582155">RKH_RQ_EN</a> is set to 1 then RKH will include the native software timer facility. </p>
</li>
<li><b>RKH_TIM_SIZEOF_NTIMER:</b> <br/>
 <p>Specify the dynamic range of the time delays measured in clock ticks (maximum number of ticks). The valid values [in bits] are 8, 16 or 32. Default is 8. </p>
</li>
<li><b>RKH_TIM_EN_HOOK:</b> <br/>
 <p>If the <a class="el" href="rkhcfg_8h.html#ac82ec4a33e5e706b1f6a1504a4f14865">RKH_TIM_EN_HOOK</a> is set to 1 then RKH will invoke a hook function when a timer expires. When this is set the application must provide the hook function. </p>
</li>
<li><b>RKH_TIM_EN_RESTART:</b> <br/>
 <p>If the <a class="el" href="rkhcfg_8h.html#ad6625254b1b17b39b47c6354c03cedd0">RKH_TIM_EN_RESTART</a> is set to 1 then RKH will include the <a class="el" href="rkhtim_8h.html#a7784197869fd89d32ec363eb6d3cfb66" title="Restart a timer with a new number of ticks.">rkh_tim_restart()</a> function that restarts a timer with a new number of ticks. See <a class="el" href="rkhtim_8h.html#a7784197869fd89d32ec363eb6d3cfb66" title="Restart a timer with a new number of ticks.">rkh_tim_restart()</a> function. </p>
</li>
<li><b>RKH_TIM_EN_GET_INFO:</b> <br/>
 <p>If the <a class="el" href="rkhcfg_8h.html#af0cea799a0270f0801ecaf7a432c4aca">RKH_TIM_EN_GET_INFO</a> is set to 1 then RKH will include the <a class="el" href="rkhtim_8h.html#aec622cb579da7722b4b6ac945a81e70f" title="Retrieves performance information for a particular software timer.">rkh_tim_get_info()</a> function that retrieves performance information for a particular software timer. See <a class="el" href="rkhtim_8h.html#aec622cb579da7722b4b6ac945a81e70f" title="Retrieves performance information for a particular software timer.">rkh_tim_get_info()</a> function. </p>
</li>
</ul>
<p>Prev: <a class="el" href="index.html#main_page">Home</a> </p>
</div></div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed May 9 2012 13:05:36 for RKH by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
