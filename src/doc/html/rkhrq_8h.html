<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RKH: rkhrq.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">RKH
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rkhrq.h File Reference</div>  </div>
</div>
<div class="contents">

<p>Platform-independent interface for supporting queue (by reference) services.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="rkhcfg_8h_source.html">rkhcfg.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="rkhtype_8h_source.html">rkhtype.h</a>&quot;</code><br/>
</div>
<p><a href="rkhrq_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_k_h___r_q_i___t.html">RKH_RQI_T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the data structure into which the performance information for queues is stored.  <a href="struct_r_k_h___r_q_i___t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the data structure used to maintain information about the queue.  <a href="struct_r_k_h_r_q___t.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhrq_8h.html#a3458b89eb6c44996ba7f9c73b1806631">rkh_rq_is_empty</a>(q)&#160;&#160;&#160;(HUInt)(rkh_rq_get_num((<a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a>*)(q))==0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro query the queue.  <a href="#a3458b89eb6c44996ba7f9c73b1806631"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef rkhui8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhrq_8h.html#a9b92c95ab477eb8e6f81dd35e16923a3">RKH_RQNE_T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This data type defines the maximum number of elements that any queue can contain.  <a href="#a9b92c95ab477eb8e6f81dd35e16923a3"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhrq_8h.html#ac4a7dacd6feb8d34e3b5310161227bc8">RKH_RQCODE_T</a> </td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhrq_8h.html#a5ea237b158ef85877afd1d27ee765463">rkh_rq_init</a> (<a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a> *q, const void **sstart, <a class="el" href="rkhrq_8h.html#a9b92c95ab477eb8e6f81dd35e16923a3">RKH_RQNE_T</a> ssize, void *sma)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the previously allocated queue data strcuture <a class="el" href="struct_r_k_h_r_q___t.html" title="Defines the data structure used to maintain information about the queue.">RKHRQ_T</a>.  <a href="#a5ea237b158ef85877afd1d27ee765463"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HUInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhrq_8h.html#ad215888d1fea1b307f1a93acb653f9c1">rkh_rq_is_full</a> (<a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a> *q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function query the queue.  <a href="#ad215888d1fea1b307f1a93acb653f9c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="rkhrq_8h.html#a9b92c95ab477eb8e6f81dd35e16923a3">RKH_RQNE_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhrq_8h.html#a3942c5c1912400ece5c9e05c6ff399a3">rkh_rq_get_num</a> (<a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a> *q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements currently in the queue.  <a href="#a3942c5c1912400ece5c9e05c6ff399a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="rkhrq_8h.html#a9b92c95ab477eb8e6f81dd35e16923a3">RKH_RQNE_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhrq_8h.html#a6f4872c1f17562395bae1daf69386888">rkh_rq_get_lwm</a> (<a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a> *q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the lowest number of free elements ever present in the pool. This number provides valuable empirical data for proper sizing of the queue.  <a href="#a6f4872c1f17562395bae1daf69386888"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhrq_8h.html#a26f0ee0f90759c88eeb68190af867ab3">rkh_rq_get</a> (<a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a> *q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get and remove an element from a queue.  <a href="#a26f0ee0f90759c88eeb68190af867ab3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhrq_8h.html#a9852abe691a371764ad835cf5c13ea01">rkh_rq_put_fifo</a> (<a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a> *q, const void *pe)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts an element on a queue in a FIFO manner. The element is queued by reference, not by copy.  <a href="#a9852abe691a371764ad835cf5c13ea01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhrq_8h.html#a3108dc32505429ab19a83bb7a7f1a2b7">rkh_rq_put_lifo</a> (<a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a> *q, const void *pe)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts an element on a queue in a LIFO manner. The element is queued by reference, not by copy.  <a href="#a3108dc32505429ab19a83bb7a7f1a2b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhrq_8h.html#a6e6031bd33bba0af4a38e2526a1f9a18">rkh_rq_deplete</a> (<a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a> *q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Depletes a queue. Empties the contents of the queue and eliminates all stored elements.  <a href="#a6e6031bd33bba0af4a38e2526a1f9a18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HUInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhrq_8h.html#adc5ac464735ce7e76455c3fe66081f55">rkh_rq_read</a> (<a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a> *q, void *pe)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an element from a queue without remove it.  <a href="#adc5ac464735ce7e76455c3fe66081f55"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhrq_8h.html#aebd782b0a777e248a1bb0b45973cbf16">rkh_rq_get_info</a> (<a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a> *q, <a class="el" href="struct_r_k_h___r_q_i___t.html">RKH_RQI_T</a> *pqi)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves performance information for a particular queue.  <a href="#aebd782b0a777e248a1bb0b45973cbf16"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhrq_8h.html#a3135fdbd93cf7721072f7c7f59118e02">rkh_rq_clear_info</a> (<a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a> *q)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear performance information for a particular queue.  <a href="#a3135fdbd93cf7721072f7c7f59118e02"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Platform-independent interface for supporting queue (by reference) services. </p>
<p>The queue is a buffer-like object through which state machine applications (SMA) and ISRs send and receive messages to communicate and synchornize with data. It temporarily holds pointer to messages from a sender until the intended receiver is ready to read them.</p>
<p>The number of messages a queue can hold depends on its message size (pointer size) and the size of the memory area supplied during creation. To calculate the total message capacity of the queue, divide the number of bytes in each message into the total number of bytes in the supplied</p>
<p>The memory area for buffering messages is specified during queue creation. It can be located anywhere in the target's address space. This is an important feature because it gives the application considerable flexibility. </p>

<p>Definition in file <a class="el" href="rkhrq_8h_source.html">rkhrq.h</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a3458b89eb6c44996ba7f9c73b1806631"></a><!-- doxytag: member="rkhrq.h::rkh_rq_is_empty" ref="a3458b89eb6c44996ba7f9c73b1806631" args="(q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rkh_rq_is_empty</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">q</td><td>)</td>
          <td>&#160;&#160;&#160;(HUInt)(rkh_rq_get_num((<a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a>*)(q))==0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This macro query the queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>pointer to previously created queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>'1' (TRUE) if queue is empty, otherwise '0' (FALSE). </dd></dl>

<p>Definition at line <a class="el" href="rkhrq_8h_source.html#l00240">240</a> of file <a class="el" href="rkhrq_8h_source.html">rkhrq.h</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a9b92c95ab477eb8e6f81dd35e16923a3"></a><!-- doxytag: member="rkhrq.h::RKH_RQNE_T" ref="a9b92c95ab477eb8e6f81dd35e16923a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef rkhui8_t <a class="el" href="rkhrq_8h.html#a9b92c95ab477eb8e6f81dd35e16923a3">RKH_RQNE_T</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This data type defines the maximum number of elements that any queue can contain. </p>
<p>The valid values [in bits] are 8, 16 or 32. Default is 8. This type is configurable via the preprocessor switch RKH_RQ_SIZEOF_NELEM. </p>

<p>Definition at line <a class="el" href="rkhrq_8h_source.html#l00068">68</a> of file <a class="el" href="rkhrq_8h_source.html">rkhrq.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ac4a7dacd6feb8d34e3b5310161227bc8"></a><!-- doxytag: member="rkhrq.h::RKH_RQCODE_T" ref="ac4a7dacd6feb8d34e3b5310161227bc8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rkhrq_8h.html#ac4a7dacd6feb8d34e3b5310161227bc8">RKH_RQCODE_T</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return codes from queue operations. </p>

<p>Definition at line <a class="el" href="rkhrq_8h_source.html#l00082">82</a> of file <a class="el" href="rkhrq_8h_source.html">rkhrq.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a5ea237b158ef85877afd1d27ee765463"></a><!-- doxytag: member="rkhrq.h::rkh_rq_init" ref="a5ea237b158ef85877afd1d27ee765463" args="(RKHRQ_T *q, const void **sstart, RKH_RQNE_T ssize, void *sma)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rkh_rq_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a> *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>sstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rkhrq_8h.html#a9b92c95ab477eb8e6f81dd35e16923a3">RKH_RQNE_T</a>&#160;</td>
          <td class="paramname"><em>ssize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes the previously allocated queue data strcuture <a class="el" href="struct_r_k_h_r_q___t.html" title="Defines the data structure used to maintain information about the queue.">RKHRQ_T</a>. </p>
<p>A queue is declared with the <a class="el" href="struct_r_k_h_r_q___t.html" title="Defines the data structure used to maintain information about the queue.">RKHRQ_T</a> data type and is defined with the <a class="el" href="rkhrq_8h.html#a5ea237b158ef85877afd1d27ee765463" title="Initializes the previously allocated queue data strcuture RKHRQ_T.">rkh_rq_init()</a> service. The total number of messages is calculated from the specified message size (pointer size) and the total number of bytes in the queue. Note that if the total number of bytes specified in the queue's memory area is not evenly divisible by the specified message size, the remaining bytes in the memory area are not used.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_r_k_h_r_q___t.html" title="Defines the data structure used to maintain information about the queue.">RKHRQ_T</a> structure for more information.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>pointer to previously allocated queue structure. </td></tr>
    <tr><td class="paramname">sstart</td><td>storage start. Pointer to an array of pointers that holds the elements. This array must be declared as an array of void pointers. </td></tr>
    <tr><td class="paramname">ssize</td><td>storage size [in the units of void pointers]. </td></tr>
    <tr><td class="paramname">sma</td><td>pointer to associated SMA that receives the enqueued events. If <em>sma</em> is set to NULL they never block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad215888d1fea1b307f1a93acb653f9c1"></a><!-- doxytag: member="rkhrq.h::rkh_rq_is_full" ref="ad215888d1fea1b307f1a93acb653f9c1" args="(RKHRQ_T *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HUInt rkh_rq_is_full </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a> *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function query the queue. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is optional, thus it could be eliminated in compile-time with RKH_RQ_EN_IS_FULL.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>pointer to previously created queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>'1' (TRUE) if queue is full, otherwise '0' (FALSE). </dd></dl>

</div>
</div>
<a class="anchor" id="a3942c5c1912400ece5c9e05c6ff399a3"></a><!-- doxytag: member="rkhrq.h::rkh_rq_get_num" ref="a3942c5c1912400ece5c9e05c6ff399a3" args="(RKHRQ_T *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rkhrq_8h.html#a9b92c95ab477eb8e6f81dd35e16923a3">RKH_RQNE_T</a> rkh_rq_get_num </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a> *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of elements currently in the queue. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is optional, thus it could be eliminated in compile-time with RKH_RQ_EN_GET_NELEMS.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>pointer to previously created queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f4872c1f17562395bae1daf69386888"></a><!-- doxytag: member="rkhrq.h::rkh_rq_get_lwm" ref="a6f4872c1f17562395bae1daf69386888" args="(RKHRQ_T *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rkhrq_8h.html#a9b92c95ab477eb8e6f81dd35e16923a3">RKH_RQNE_T</a> rkh_rq_get_lwm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a> *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns the lowest number of free elements ever present in the pool. This number provides valuable empirical data for proper sizing of the queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>pointer to previously created queue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is optional, thus it could be eliminated in compile-time with RKH_RQ_EN_GET_LWMARK.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Lowest number of free elements ever present in the queue. </dd></dl>

</div>
</div>
<a class="anchor" id="a26f0ee0f90759c88eeb68190af867ab3"></a><!-- doxytag: member="rkhrq.h::rkh_rq_get" ref="a26f0ee0f90759c88eeb68190af867ab3" args="(RKHRQ_T *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* rkh_rq_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a> *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get and remove an element from a queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>pointer to previously created queue from which the elements are received. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9852abe691a371764ad835cf5c13ea01"></a><!-- doxytag: member="rkhrq.h::rkh_rq_put_fifo" ref="a9852abe691a371764ad835cf5c13ea01" args="(RKHRQ_T *q, const void *pe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rkh_rq_put_fifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a> *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Puts an element on a queue in a FIFO manner. The element is queued by reference, not by copy. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The function raises an assertion if the queue becomes full and cannot accept the element.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>pointer to previously created queue into which the element is deposited. </td></tr>
    <tr><td class="paramname">pe</td><td>pointer-sized variable and is application specific. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3108dc32505429ab19a83bb7a7f1a2b7"></a><!-- doxytag: member="rkhrq.h::rkh_rq_put_lifo" ref="a3108dc32505429ab19a83bb7a7f1a2b7" args="(RKHRQ_T *q, const void *pe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rkh_rq_put_lifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a> *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Puts an element on a queue in a LIFO manner. The element is queued by reference, not by copy. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The function raises an assertion if the queue becomes full and cannot accept the element. </dd>
<dd>
This function is optional, thus it could be eliminated in compile-time with RKH_RQ_EN_PUT_LIFO.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>pointer to previously created queue into which the element is deposited. </td></tr>
    <tr><td class="paramname">pe</td><td>pointer-sized variable and is application specific. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e6031bd33bba0af4a38e2526a1f9a18"></a><!-- doxytag: member="rkhrq.h::rkh_rq_deplete" ref="a6e6031bd33bba0af4a38e2526a1f9a18" args="(RKHRQ_T *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rkh_rq_deplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a> *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Depletes a queue. Empties the contents of the queue and eliminates all stored elements. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function should be used with great care because, when to flush the queue, the references are LOOSE to what the queue entries are pointing to and thus, could cause 'memory leaks'. In other words, the data pointing to that's being referenced by the queue entries should, most likely, need to be deallocated. To flush a queue that contains entries, is much safer instead repeateadly use <a class="el" href="rkhrq_8h.html#a26f0ee0f90759c88eeb68190af867ab3" title="Get and remove an element from a queue.">rkh_rq_get()</a>.</dd>
<dd>
This function is optional, thus it could be eliminated in compile-time with RKH_RQ_EN_DEPLETE.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>pointer to previously created queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc5ac464735ce7e76455c3fe66081f55"></a><!-- doxytag: member="rkhrq.h::rkh_rq_read" ref="adc5ac464735ce7e76455c3fe66081f55" args="(RKHRQ_T *q, void *pe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HUInt rkh_rq_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a> *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read an element from a queue without remove it. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is optional, thus it could be eliminated in compile-time with RKH_RQ_EN_READ.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>pointer to previously created queue from which the elements are received. </td></tr>
    <tr><td class="paramname">pe</td><td>pointer to the buffer into which the received item will be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>RKH_RQ_OK if an element was successfully readed from the queue, otherwise error code. </dd></dl>

</div>
</div>
<a class="anchor" id="aebd782b0a777e248a1bb0b45973cbf16"></a><!-- doxytag: member="rkhrq.h::rkh_rq_get_info" ref="aebd782b0a777e248a1bb0b45973cbf16" args="(RKHRQ_T *q, RKH_RQI_T *pqi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rkh_rq_get_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a> *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_r_k_h___r_q_i___t.html">RKH_RQI_T</a> *&#160;</td>
          <td class="paramname"><em>pqi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves performance information for a particular queue. </p>
<p>The user application must allocate an <a class="el" href="struct_r_k_h___r_q_i___t.html" title="Defines the data structure into which the performance information for queues is stored.">RKH_RQI_T</a> data structure used to receive data. The performance information is available during run-time for each of the RKH services. This can be useful in determining whether the application is performing properly, as well as helping to optimize the application. This information provides a "snapshot" a particular instant in time, i.e., when the service is invoked.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>See <a class="el" href="struct_r_k_h___r_q_i___t.html" title="Defines the data structure into which the performance information for queues is stored.">RKH_RQI_T</a> structure for more information. This function is optional, thus it could be eliminated in compile-time with RKH_RQ_EN_GET_INFO.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>pointer to previously created queue. </td></tr>
    <tr><td class="paramname">pqi</td><td>pointer to the buffer into which the performance information will be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3135fdbd93cf7721072f7c7f59118e02"></a><!-- doxytag: member="rkhrq.h::rkh_rq_clear_info" ref="a3135fdbd93cf7721072f7c7f59118e02" args="(RKHRQ_T *q)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rkh_rq_clear_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_r_k_h_r_q___t.html">RKHRQ_T</a> *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear performance information for a particular queue. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is optional, thus it could be eliminated in compile-time with RKH_RQ_EN_GET_INFO.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>pointer to previously created queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed May 9 2012 13:05:35 for RKH by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
