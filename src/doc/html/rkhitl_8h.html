<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RKH: rkhitl.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">RKH
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">rkhitl.h File Reference</div>  </div>
</div>
<div class="contents">

<p>RKH engine interface.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="rkhcfg_8h_source.html">rkhcfg.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="rkhplat_8h_source.html">rkhplat.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="rkhtype_8h_source.html">rkhtype.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="rkhtrc_8h_source.html">rkhtrc.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="rkhevt_8h_source.html">rkhevt.h</a>&quot;</code><br/>
</div>
<p><a href="rkhitl_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_k_h___s_m_a_i___t.html">RKH_SMAI_T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the data structure into which the collected performance information for state machine is stored.  <a href="struct_r_k_h___s_m_a_i___t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_o_m_r_k_h___t.html">ROMRKH_T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant parameters of state machine.  <a href="struct_r_o_m_r_k_h___t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_k_h_s_m_a___t.html">RKHSMA_T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the SMA (active object in UML).  <a href="struct_r_k_h_s_m_a___t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_k_h_b_a_s_e___t.html">RKHBASE_T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains the basic information of a state.  <a href="struct_r_k_h_b_a_s_e___t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_k_h_t_r___t.html">RKHTR_T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the state transition.  <a href="struct_r_k_h_t_r___t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_k_h_e_x_p_c_n___t.html">RKHEXPCN_T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the exit point connection.  <a href="struct_r_k_h_e_x_p_c_n___t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_k_h_e_n_p_c_n___t.html">RKHENPCN_T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the entry point connection.  <a href="struct_r_k_h_e_n_p_c_n___t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_k_h_s_t___t.html">RKHST_T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the common properties of regular states (basic, composite, and submachine).  <a href="struct_r_k_h_s_t___t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_k_h_s_b_s_c___t.html">RKHSBSC_T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a basic state.  <a href="struct_r_k_h_s_b_s_c___t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_k_h_s_c_m_p___t.html">RKHSCMP_T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a composite state.  <a href="struct_r_k_h_s_c_m_p___t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_k_h_s_s_b_m___t.html">RKHSSBM_T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a submachine state.  <a href="struct_r_k_h_s_s_b_m___t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_k_h_r_s_m___t.html">RKHRSM_T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a (referenced) submachine state machine.  <a href="struct_r_k_h_r_s_m___t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_k_h_s_e_n_p___t.html">RKHSENP_T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the entry point pseudostate.  <a href="struct_r_k_h_s_e_n_p___t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_k_h_s_e_x_p___t.html">RKHSEXP_T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the exit point pseudostate.  <a href="struct_r_k_h_s_e_x_p___t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_k_h_s_c_o_n_d___t.html">RKHSCOND_T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the conditional pseudostate.  <a href="struct_r_k_h_s_c_o_n_d___t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_k_h_s_j_u_n_c___t.html">RKHSJUNC_T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the junction pseudostate.  <a href="struct_r_k_h_s_j_u_n_c___t.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_r_k_h_s_h_i_s_t___t.html">RKHSHIST_T</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the history pseudostate.  <a href="struct_r_k_h_s_h_i_s_t___t.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#a2632ebe5c92ba1e4c8bfac5d39712264">RKH_VERSION_CODE</a>&#160;&#160;&#160;0x2100U</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro expands to the binary representation of the RKH version.  <a href="#a2632ebe5c92ba1e4c8bfac5d39712264"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af68b848acd1eefad3e96392c33a3e821"></a><!-- doxytag: member="rkhitl.h::RKH_RELEASE" ref="af68b848acd1eefad3e96392c33a3e821" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#af68b848acd1eefad3e96392c33a3e821">RKH_RELEASE</a>&#160;&#160;&#160;<a class="el" href="rkh_8h.html#a8f2606f345f93aaea0cfe3d68b2985c1">rkh_version</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro retrieves a pointer to string describing the RKH version. For example, "2.2.04". <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#a46c44abf142453d62ab2f7e07d94ba5f">RKH_VERSION</a>(a, b, c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the macro used to build an integer version code from the individual numbers that build up a version number.  <a href="#a46c44abf142453d62ab2f7e07d94ba5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#abd3571be44849ed0b7bf73ed08af9596">RKH_ANY</a>&#160;&#160;&#160;((<a class="el" href="rkhevt_8h.html#a8a78cec3a9dfc2336bd084c221e15e10">RKHE_T</a>)(-1))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#a62eb26927897cf1441ddfe4caf8f1be2">RKH_EQ_TYPE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#a5a9dfdafe21b301459505206ac572c05">RKH_THREAD_TYPE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#a475f9c2c1439b114e4266a642572de15">RKH_OSDATA_TYPE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#aef5296870b61cf45a868f02602e31340">RKH_SMA_BLOCK</a>(sma)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates the mechanism of blocking the event queue.  <a href="#aef5296870b61cf45a868f02602e31340"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#a6775845b41cbe4a59cc936b0730623a3">RKH_SMA_READY</a>(rg, sma)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates the mechanism of signaling the thread waiting on the used event queue. Thus, the SMA is inserted in the ready list as ready-to-dispatch.  <a href="#a6775845b41cbe4a59cc936b0730623a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#aade2f6ff9a19302e2b61e69b2417fde8">RKH_SMA_UNREADY</a>(rg, sma)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Informs the underlying kernel that the SMA event queue is becoming empty. Thus, the SMA is removed from the ready list.  <a href="#aade2f6ff9a19302e2b61e69b2417fde8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#a34d498dac1165ba1d4ea7dbe71ef7411">RKH_DYNE_TYPE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the data type of the fixed-size memory block for dynamic event support.  <a href="#a34d498dac1165ba1d4ea7dbe71ef7411"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#a4b5aee3c127ac9c2618c2452b6bd65b2">RKH_DYNE_INIT</a>(mp, sstart, ssize, esize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates the creation of a event pool.  <a href="#a4b5aee3c127ac9c2618c2452b6bd65b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#ae5c52c17f40c4119b0aebffacf4ecb04">RKH_DYNE_GET_ESIZE</a>(mp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates how RKH should obtain the block size of pool.  <a href="#ae5c52c17f40c4119b0aebffacf4ecb04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#a90dcc5b49faff4d8dde016f8aea160fa">RKH_DYNE_GET</a>(mp, e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates how RKH should obtain an event <code>e</code> from the event pool <code>mp</code>.  <a href="#a90dcc5b49faff4d8dde016f8aea160fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#a3d3e4448b8b4fdaef1501bf2723b0cde">RKH_DYNE_PUT</a>(mp, e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates how RKH should return an event <code>e</code> to the event pool <code>mp</code>.  <a href="#a3d3e4448b8b4fdaef1501bf2723b0cde"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#a5e8366e36b0290e15bd75988390cc760">RKH_DIS_INTERRUPT</a>()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#aed1d3d5ccbd9ff2fb694e809e494759d">RKH_ENA_INTERRUPT</a>()</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#a080a9f3b8050eaa0054af6d51c39f252">RKH_CPUSR_TYPE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts when done.  <a href="#a080a9f3b8050eaa0054af6d51c39f252"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#a049663a78a9108ce08c76840a30ff798">RKH_SR_CRITICAL_</a>&#160;&#160;&#160;RKH_CPUSR_TYPE sr</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts when done.  <a href="#a049663a78a9108ce08c76840a30ff798"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#a7401fd42aebee28b2e6eef2a9e4634e2">RKH_ENTER_CRITICAL</a>(dummy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts when done.  <a href="#a7401fd42aebee28b2e6eef2a9e4634e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#a42bd908ca2b52b24bb823187ba800076">RKH_EXIT_CRITICAL</a>(dummy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts when done.  <a href="#a42bd908ca2b52b24bb823187ba800076"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#a01eeee85f42a27c3864b8c5fb04e1074">RKHINIT_T</a> )(const void *sma, const struct rkhevt_t *e)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization action.  <a href="#a01eeee85f42a27c3864b8c5fb04e1074"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#ac4007c2a9c7684557d4b72b1e6157070">RKHENT_T</a> )(const struct rkhsma_t *sma)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry action.  <a href="#ac4007c2a9c7684557d4b72b1e6157070"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#ab9e5faba972278beb83d7fd998774aa3">RKHEXT_T</a> )(const struct rkhsma_t *sma)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit action.  <a href="#ab9e5faba972278beb83d7fd998774aa3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="rkhevt_8h.html#a8a78cec3a9dfc2336bd084c221e15e10">RKHE_T</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#a3f1afca9ba9935082740bf026862729c">RKHPPRO_T</a> )(const struct rkhsma_t *sma, <a class="el" href="struct_r_k_h_e_v_t___t.html">RKHEVT_T</a> *pe)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Event preprocessor.  <a href="#a3f1afca9ba9935082740bf026862729c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#a5b907a35e91da0cbe44d7ea879fdd001">RKHACT_T</a> )(const struct rkhsma_t *sma, <a class="el" href="struct_r_k_h_e_v_t___t.html">RKHEVT_T</a> *pe)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transition action.  <a href="#a5b907a35e91da0cbe44d7ea879fdd001"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef HUInt(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rkhitl_8h.html#a9d6ea7aab791f836c1a28d2c8b13af3a">RKHGUARD_T</a> )(const struct rkhsma_t *sma, <a class="el" href="struct_r_k_h_e_v_t___t.html">RKHEVT_T</a> *pe)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Guard.  <a href="#a9d6ea7aab791f836c1a28d2c8b13af3a"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>RKH engine interface. </p>
<p>This header file is directly included in RKH interface file, <a class="el" href="rkh_8h.html" title="RKH platform-independent interface.">rkh.h</a>. </p>

<p>Definition in file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a2632ebe5c92ba1e4c8bfac5d39712264"></a><!-- doxytag: member="rkhitl.h::RKH_VERSION_CODE" ref="a2632ebe5c92ba1e4c8bfac5d39712264" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RKH_VERSION_CODE&#160;&#160;&#160;0x2100U</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This macro expands to the binary representation of the RKH version. </p>
<p>Application specific configuration options. Specific definitions to the platform being used. Trace facility. Event data type and related macros. The version number is composed as 0xABCC, where: the number A (1-digit) denoted the major revision, the number B (1-digit) denoted the minor revision, and the number C (2-digit) indicated the release number. For example, the code for 2.2.04 is 0x2204.</p>
<p>Date: xx/xx/2012 </p>

<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l00080">80</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a46c44abf142453d62ab2f7e07d94ba5f"></a><!-- doxytag: member="rkhitl.h::RKH_VERSION" ref="a46c44abf142453d62ab2f7e07d94ba5f" args="(a, b, c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RKH_VERSION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the macro used to build an integer version code from the individual numbers that build up a version number. </p>
<p>For example, <a class="el" href="rkhitl_8h.html#a46c44abf142453d62ab2f7e07d94ba5f" title="This is the macro used to build an integer version code from the individual numbers that build up a v...">RKH_VERSION(2,2,04)</a> expands to 0x2204. This macro is very useful when needs to compare the current version and a known checkpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>major revision </td></tr>
    <tr><td class="paramname">b</td><td>minor revision </td></tr>
    <tr><td class="paramname">c</td><td>release number </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l00105">105</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="abd3571be44849ed0b7bf73ed08af9596"></a><!-- doxytag: member="rkhitl.h::RKH_ANY" ref="abd3571be44849ed0b7bf73ed08af9596" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RKH_ANY&#160;&#160;&#160;((<a class="el" href="rkhevt_8h.html#a8a78cec3a9dfc2336bd084c221e15e10">RKHE_T</a>)(-1))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro is used to indicate the end of a transition table. </p>

<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l00112">112</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a62eb26927897cf1441ddfe4caf8f1be2"></a><!-- doxytag: member="rkhitl.h::RKH_EQ_TYPE" ref="a62eb26927897cf1441ddfe4caf8f1be2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RKH_EQ_TYPE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines the data type of the event queue for active objects. The event queue can be implemented with a message queue of the RTOS/OS. But it is also possible to use the native RKH queue <a class="el" href="struct_r_k_h_r_q___t.html" title="Defines the data structure used to maintain information about the queue.">RKHRQ_T</a> type if the underlying RTOS/OS does not provide an adequate queue.</p>
<p><em>Example for using the native queue</em> </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #define RKH_EQ_TYPE         RKHRQ_T</span>
</pre></div> 
<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l00558">558</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5a9dfdafe21b301459505206ac572c05"></a><!-- doxytag: member="rkhitl.h::RKH_THREAD_TYPE" ref="a5a9dfdafe21b301459505206ac572c05" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RKH_THREAD_TYPE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The data type RKH_THREAD_TYPE holds the thread handle associated with the active object.</p>
<p><em>Example for using the native scheduler</em> </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #define RKH_THREAD_TYPE     RKHSMA_T</span>
</pre></div> 
<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l00570">570</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a475f9c2c1439b114e4266a642572de15"></a><!-- doxytag: member="rkhitl.h::RKH_OSDATA_TYPE" ref="a475f9c2c1439b114e4266a642572de15" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RKH_OSDATA_TYPE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The RKH_OSDATA_TYPE data member is necessary when the underlying OS does not provide an adequate queue facility, so the native RKH queue <a class="el" href="struct_r_k_h_r_q___t.html" title="Defines the data structure used to maintain information about the queue.">RKHRQ_T</a> must be used. In this case the RKH_OSDATA_TYPE data member holds an operating system specific primitive to efficiently block the native RKH event queue when the queue is empty. </p>

<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l00580">580</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5e8366e36b0290e15bd75988390cc760"></a><!-- doxytag: member="rkhitl.h::RKH_DIS_INTERRUPT" ref="a5e8366e36b0290e15bd75988390cc760" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RKH_DIS_INTERRUPT</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts when done. This allows RKH to protect critical code from being entered simultaneously. To hide the implementation method chosen by the processor, compiler, etc, RKH defines two macros to unconditionally disable and enable interrupts: <a class="el" href="rkhitl_8h.html#a5e8366e36b0290e15bd75988390cc760">RKH_DIS_INTERRUPT()</a> and <a class="el" href="rkhitl_8h.html#aed1d3d5ccbd9ff2fb694e809e494759d">RKH_ENA_INTERRUPT()</a> respectively. Obviously, they resides in <b>rkhport.h</b> file, which the user always need to provide.</p>
<p><em>Example for HCS08 CW6.3 from C:</em> </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #define RKH_DIS_INTERRUPT()         DisableInterrupts</span>
<span class="preprocessor">    #define RKH_ENA_INTERRUPT()         EnableInterrupts</span>
</pre></div> 
<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l00599">599</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="aed1d3d5ccbd9ff2fb694e809e494759d"></a><!-- doxytag: member="rkhitl.h::RKH_ENA_INTERRUPT" ref="aed1d3d5ccbd9ff2fb694e809e494759d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RKH_ENA_INTERRUPT</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts when done. This allows RKH to protect critical code from being entered simultaneously. To hide the implementation method chosen by the processor, compiler, etc, RKH defines two macros to unconditionally disable and enable interrupts: <a class="el" href="rkhitl_8h.html#a5e8366e36b0290e15bd75988390cc760">RKH_DIS_INTERRUPT()</a> and <a class="el" href="rkhitl_8h.html#aed1d3d5ccbd9ff2fb694e809e494759d">RKH_ENA_INTERRUPT()</a> respectively. Obviously, they resides in <b>rkhport.h</b> file, which the user always need to provide.</p>
<p><em>Example for HCS08 CW6.3 from C:</em> </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #define RKH_DIS_INTERRUPT()         DisableInterrupts</span>
<span class="preprocessor">    #define RKH_ENA_INTERRUPT()         EnableInterrupts</span>
</pre></div> 
<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l00600">600</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a080a9f3b8050eaa0054af6d51c39f252"></a><!-- doxytag: member="rkhitl.h::RKH_CPUSR_TYPE" ref="a080a9f3b8050eaa0054af6d51c39f252" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RKH_CPUSR_TYPE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts when done. </p>
<p>This allows RKH to protect critical code from being entered simultaneously from either multiple SMAs or ISRs. Every processor generally provide instructions to disable/enable interrupts and the C compiler must have a mechanism to perform these operations directly from C. Some compilers will allows to insert in-line assembly language statements in the C source code. This makes it quite easy to insert processor instructions to enable and disable interrupts. Other compilers will actually contain language extensions to enable and disable interrupts directly from C. To hide the implementation method chosen by the compiler manufacturer, RKH defines two macros to disable and enable interrupts: <a class="el" href="rkhitl_8h.html#a7401fd42aebee28b2e6eef2a9e4634e2" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_ENTER_CRITICAL()</a> and <a class="el" href="rkhitl_8h.html#a42bd908ca2b52b24bb823187ba800076" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_EXIT_CRITICAL()</a>.</p>
<p>The <a class="el" href="rkhitl_8h.html#a7401fd42aebee28b2e6eef2a9e4634e2" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_ENTER_CRITICAL()</a> macro saves the interrupt disable status onto the stack and then, disable interrupts. <a class="el" href="rkhitl_8h.html#a42bd908ca2b52b24bb823187ba800076" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_EXIT_CRITICAL()</a> would simply be implemented by restoring the interrupt status from the stack. Using this scheme, if it's called a RKH service with either interrupts enabled or disabled then, the status would be preserved across the call. If calls a RKH service with interrupts disabled, is potentially extending the interrupt latency of application. The application can use <a class="el" href="rkhitl_8h.html#a7401fd42aebee28b2e6eef2a9e4634e2" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_ENTER_CRITICAL()</a> and <a class="el" href="rkhitl_8h.html#a42bd908ca2b52b24bb823187ba800076" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_EXIT_CRITICAL()</a> to also protect critical sections of code. As a general rule, should always call RKH services with interrupts enabled!.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>These macros are internal to RKH and the user application should not call it.</dd></dl>
<p><em>Example for x86, VC2008, and win32 single thread:</em> </p>
<div class="fragment"><pre class="fragment">    <span class="comment">//#define RKH_CPUSR_TYPE</span>
<span class="preprocessor">    #define RKH_ENTER_CRITICAL( dummy )     EnterCriticalSection( &amp;csection )</span>
<span class="preprocessor">    #define RKH_EXIT_CRITICAL( dummy )      LeaveCriticalSection( &amp;csection )</span>
</pre></div> 
<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l00645">645</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a049663a78a9108ce08c76840a30ff798"></a><!-- doxytag: member="rkhitl.h::RKH_SR_CRITICAL_" ref="a049663a78a9108ce08c76840a30ff798" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RKH_SR_CRITICAL_&#160;&#160;&#160;RKH_CPUSR_TYPE sr</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts when done. </p>
<p>This allows RKH to protect critical code from being entered simultaneously from either multiple SMAs or ISRs. Every processor generally provide instructions to disable/enable interrupts and the C compiler must have a mechanism to perform these operations directly from C. Some compilers will allows to insert in-line assembly language statements in the C source code. This makes it quite easy to insert processor instructions to enable and disable interrupts. Other compilers will actually contain language extensions to enable and disable interrupts directly from C. To hide the implementation method chosen by the compiler manufacturer, RKH defines two macros to disable and enable interrupts: <a class="el" href="rkhitl_8h.html#a7401fd42aebee28b2e6eef2a9e4634e2" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_ENTER_CRITICAL()</a> and <a class="el" href="rkhitl_8h.html#a42bd908ca2b52b24bb823187ba800076" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_EXIT_CRITICAL()</a>.</p>
<p>The <a class="el" href="rkhitl_8h.html#a7401fd42aebee28b2e6eef2a9e4634e2" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_ENTER_CRITICAL()</a> macro saves the interrupt disable status onto the stack and then, disable interrupts. <a class="el" href="rkhitl_8h.html#a42bd908ca2b52b24bb823187ba800076" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_EXIT_CRITICAL()</a> would simply be implemented by restoring the interrupt status from the stack. Using this scheme, if it's called a RKH service with either interrupts enabled or disabled then, the status would be preserved across the call. If calls a RKH service with interrupts disabled, is potentially extending the interrupt latency of application. The application can use <a class="el" href="rkhitl_8h.html#a7401fd42aebee28b2e6eef2a9e4634e2" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_ENTER_CRITICAL()</a> and <a class="el" href="rkhitl_8h.html#a42bd908ca2b52b24bb823187ba800076" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_EXIT_CRITICAL()</a> to also protect critical sections of code. As a general rule, should always call RKH services with interrupts enabled!.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>These macros are internal to RKH and the user application should not call it.</dd></dl>
<p><em>Example for x86, VC2008, and win32 single thread:</em> </p>
<div class="fragment"><pre class="fragment">    <span class="comment">//#define RKH_CPUSR_TYPE</span>
<span class="preprocessor">    #define RKH_ENTER_CRITICAL( dummy )     EnterCriticalSection( &amp;csection )</span>
<span class="preprocessor">    #define RKH_EXIT_CRITICAL( dummy )      LeaveCriticalSection( &amp;csection )</span>
</pre></div> 
<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l00646">646</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7401fd42aebee28b2e6eef2a9e4634e2"></a><!-- doxytag: member="rkhitl.h::RKH_ENTER_CRITICAL" ref="a7401fd42aebee28b2e6eef2a9e4634e2" args="(dummy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RKH_ENTER_CRITICAL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dummy</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts when done. </p>
<p>This allows RKH to protect critical code from being entered simultaneously from either multiple SMAs or ISRs. Every processor generally provide instructions to disable/enable interrupts and the C compiler must have a mechanism to perform these operations directly from C. Some compilers will allows to insert in-line assembly language statements in the C source code. This makes it quite easy to insert processor instructions to enable and disable interrupts. Other compilers will actually contain language extensions to enable and disable interrupts directly from C. To hide the implementation method chosen by the compiler manufacturer, RKH defines two macros to disable and enable interrupts: <a class="el" href="rkhitl_8h.html#a7401fd42aebee28b2e6eef2a9e4634e2" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_ENTER_CRITICAL()</a> and <a class="el" href="rkhitl_8h.html#a42bd908ca2b52b24bb823187ba800076" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_EXIT_CRITICAL()</a>.</p>
<p>The <a class="el" href="rkhitl_8h.html#a7401fd42aebee28b2e6eef2a9e4634e2" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_ENTER_CRITICAL()</a> macro saves the interrupt disable status onto the stack and then, disable interrupts. <a class="el" href="rkhitl_8h.html#a42bd908ca2b52b24bb823187ba800076" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_EXIT_CRITICAL()</a> would simply be implemented by restoring the interrupt status from the stack. Using this scheme, if it's called a RKH service with either interrupts enabled or disabled then, the status would be preserved across the call. If calls a RKH service with interrupts disabled, is potentially extending the interrupt latency of application. The application can use <a class="el" href="rkhitl_8h.html#a7401fd42aebee28b2e6eef2a9e4634e2" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_ENTER_CRITICAL()</a> and <a class="el" href="rkhitl_8h.html#a42bd908ca2b52b24bb823187ba800076" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_EXIT_CRITICAL()</a> to also protect critical sections of code. As a general rule, should always call RKH services with interrupts enabled!.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>These macros are internal to RKH and the user application should not call it.</dd></dl>
<p><em>Example for x86, VC2008, and win32 single thread:</em> </p>
<div class="fragment"><pre class="fragment">    <span class="comment">//#define RKH_CPUSR_TYPE</span>
<span class="preprocessor">    #define RKH_ENTER_CRITICAL( dummy )     EnterCriticalSection( &amp;csection )</span>
<span class="preprocessor">    #define RKH_EXIT_CRITICAL( dummy )      LeaveCriticalSection( &amp;csection )</span>
</pre></div> 
<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l00647">647</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a42bd908ca2b52b24bb823187ba800076"></a><!-- doxytag: member="rkhitl.h::RKH_EXIT_CRITICAL" ref="a42bd908ca2b52b24bb823187ba800076" args="(dummy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RKH_EXIT_CRITICAL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dummy</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts when done. </p>
<p>This allows RKH to protect critical code from being entered simultaneously from either multiple SMAs or ISRs. Every processor generally provide instructions to disable/enable interrupts and the C compiler must have a mechanism to perform these operations directly from C. Some compilers will allows to insert in-line assembly language statements in the C source code. This makes it quite easy to insert processor instructions to enable and disable interrupts. Other compilers will actually contain language extensions to enable and disable interrupts directly from C. To hide the implementation method chosen by the compiler manufacturer, RKH defines two macros to disable and enable interrupts: <a class="el" href="rkhitl_8h.html#a7401fd42aebee28b2e6eef2a9e4634e2" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_ENTER_CRITICAL()</a> and <a class="el" href="rkhitl_8h.html#a42bd908ca2b52b24bb823187ba800076" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_EXIT_CRITICAL()</a>.</p>
<p>The <a class="el" href="rkhitl_8h.html#a7401fd42aebee28b2e6eef2a9e4634e2" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_ENTER_CRITICAL()</a> macro saves the interrupt disable status onto the stack and then, disable interrupts. <a class="el" href="rkhitl_8h.html#a42bd908ca2b52b24bb823187ba800076" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_EXIT_CRITICAL()</a> would simply be implemented by restoring the interrupt status from the stack. Using this scheme, if it's called a RKH service with either interrupts enabled or disabled then, the status would be preserved across the call. If calls a RKH service with interrupts disabled, is potentially extending the interrupt latency of application. The application can use <a class="el" href="rkhitl_8h.html#a7401fd42aebee28b2e6eef2a9e4634e2" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_ENTER_CRITICAL()</a> and <a class="el" href="rkhitl_8h.html#a42bd908ca2b52b24bb823187ba800076" title="RKH need to disable interrupts in order to access critical sections of code, and re-enable interrupts...">RKH_EXIT_CRITICAL()</a> to also protect critical sections of code. As a general rule, should always call RKH services with interrupts enabled!.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>These macros are internal to RKH and the user application should not call it.</dd></dl>
<p><em>Example for x86, VC2008, and win32 single thread:</em> </p>
<div class="fragment"><pre class="fragment">    <span class="comment">//#define RKH_CPUSR_TYPE</span>
<span class="preprocessor">    #define RKH_ENTER_CRITICAL( dummy )     EnterCriticalSection( &amp;csection )</span>
<span class="preprocessor">    #define RKH_EXIT_CRITICAL( dummy )      LeaveCriticalSection( &amp;csection )</span>
</pre></div> 
<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l00648">648</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="aef5296870b61cf45a868f02602e31340"></a><!-- doxytag: member="rkhitl.h::RKH_SMA_BLOCK" ref="aef5296870b61cf45a868f02602e31340" args="(sma)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RKH_SMA_BLOCK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sma</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encapsulates the mechanism of blocking the event queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sma</td><td>pointer to SMA. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l00659">659</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6775845b41cbe4a59cc936b0730623a3"></a><!-- doxytag: member="rkhitl.h::RKH_SMA_READY" ref="a6775845b41cbe4a59cc936b0730623a3" args="(rg, sma)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RKH_SMA_READY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sma&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encapsulates the mechanism of signaling the thread waiting on the used event queue. Thus, the SMA is inserted in the ready list as ready-to-dispatch. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rg</td><td>ready group. </td></tr>
    <tr><td class="paramname">sma</td><td>pointer to SMA. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l00671">671</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="aade2f6ff9a19302e2b61e69b2417fde8"></a><!-- doxytag: member="rkhitl.h::RKH_SMA_UNREADY" ref="aade2f6ff9a19302e2b61e69b2417fde8" args="(rg, sma)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RKH_SMA_UNREADY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sma&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Informs the underlying kernel that the SMA event queue is becoming empty. Thus, the SMA is removed from the ready list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rg</td><td>ready group. </td></tr>
    <tr><td class="paramname">sma</td><td>pointer to SMA. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l00682">682</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a34d498dac1165ba1d4ea7dbe71ef7411"></a><!-- doxytag: member="rkhitl.h::RKH_DYNE_TYPE" ref="a34d498dac1165ba1d4ea7dbe71ef7411" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RKH_DYNE_TYPE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Defines the data type of the fixed-size memory block for dynamic event support. </p>
<p>The fixed-size memory block can be implemented with a RTOS/OS service provided to that. But it's also possible to use the native RKH fixed-size memory block <a class="el" href="struct_r_k_h_m_p___t.html" title="Defines the data structure used to memory block pool facility.">RKHMP_T</a> type if the underlying RTOS/OS does not provide an adequate support. </p>

<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l00696">696</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4b5aee3c127ac9c2618c2452b6bd65b2"></a><!-- doxytag: member="rkhitl.h::RKH_DYNE_INIT" ref="a4b5aee3c127ac9c2618c2452b6bd65b2" args="(mp, sstart, ssize, esize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RKH_DYNE_INIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sstart, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ssize, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">esize&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encapsulates the creation of a event pool. </p>
<p>Platform-dependent macro. Typically, must be define it in the specific port file (rkhport.h).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>pointer to previously allocated memory pool structure. </td></tr>
    <tr><td class="paramname">sstart</td><td>storage start. Pointer to memory from which memory blocks are allocated. </td></tr>
    <tr><td class="paramname">ssize,:</td><td>storage size. Size of the memory pool storage in bytes. </td></tr>
    <tr><td class="paramname">esize</td><td>event size. This number determines the size of each memory block in the pool. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l00713">713</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae5c52c17f40c4119b0aebffacf4ecb04"></a><!-- doxytag: member="rkhitl.h::RKH_DYNE_GET_ESIZE" ref="ae5c52c17f40c4119b0aebffacf4ecb04" args="(mp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RKH_DYNE_GET_ESIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mp</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encapsulates how RKH should obtain the block size of pool. </p>
<p>Platform-dependent macro. Typically, must be define it in the specific port file (rkhport.h).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>pointer to previously allocated memory pool structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l00725">725</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a90dcc5b49faff4d8dde016f8aea160fa"></a><!-- doxytag: member="rkhitl.h::RKH_DYNE_GET" ref="a90dcc5b49faff4d8dde016f8aea160fa" args="(mp, e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RKH_DYNE_GET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encapsulates how RKH should obtain an event <code>e</code> from the event pool <code>mp</code>. </p>
<p>Platform-dependent macro. Typically, must be define it in the specific port file (rkhport.h).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>pointer to previously allocated memory pool structure. </td></tr>
    <tr><td class="paramname">e</td><td>pointer to a new event or NULL if the pool runs out of blocks. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l00740">740</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3d3e4448b8b4fdaef1501bf2723b0cde"></a><!-- doxytag: member="rkhitl.h::RKH_DYNE_PUT" ref="a3d3e4448b8b4fdaef1501bf2723b0cde" args="(mp, e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RKH_DYNE_PUT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encapsulates how RKH should return an event <code>e</code> to the event pool <code>mp</code>. </p>
<p>Platform-dependent macro. Typically, must be define it in the specific port file (rkhport.h).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>pointer to previously allocated memory pool structure. </td></tr>
    <tr><td class="paramname">e</td><td>pointer to the returned event. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l00754">754</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a01eeee85f42a27c3864b8c5fb04e1074"></a><!-- doxytag: member="rkhitl.h::RKHINIT_T" ref="a01eeee85f42a27c3864b8c5fb04e1074" args=")(const void *sma, const struct rkhevt_t *e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( * <a class="el" href="rkhitl_8h.html#a01eeee85f42a27c3864b8c5fb04e1074">RKHINIT_T</a>)(const void *sma, const struct rkhevt_t *e)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialization action. </p>
<p>Frequently, the state transition originating at the black ball is called the initial transition. Such transition designates the first active state after the state machine object is created. An initial transition can have associated actions, which in the UML notation are enlisted after the forward slash (/). In RKH framework, the application code must trigger the initial transition explicitly by invoking <a class="el" href="rkh_8h.html#a02d78c8f4c9f8e2b9fb0cf57711c1220" title="Initializes and activates a previously created state machine application.">rkh_sma_activate()</a> function. </p>

<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l00864">864</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac4007c2a9c7684557d4b72b1e6157070"></a><!-- doxytag: member="rkhitl.h::RKHENT_T" ref="ac4007c2a9c7684557d4b72b1e6157070" args=")(const struct rkhsma_t *sma)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( * <a class="el" href="rkhitl_8h.html#ac4007c2a9c7684557d4b72b1e6157070">RKHENT_T</a>)(const struct rkhsma_t *sma)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Entry action. </p>
<p>The actions that are always executed when a state is entered should be specified as entry actions. UML statecharts provide optional entry and exit actions, which are associated with states rather than transitions, as in a Moore automaton. An entry function takes the state machine pointer as argument. This argument is optional, thus it could be eliminated in compile-time by means of RKH_SMA_EN_ENT_ARG_SMA.</p>
<p>The RKH implementation preserves the transition sequence imposed by Harel's Statechart and UML. Specifically, the implemented transition sequence is as follows:</p>
<p>1. Execute exit actions of the source state. 2. Execute the transition actions. 3. Execute entry actions of the target state.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This callback is referenced from <a class="el" href="rkh_8h.html#acc24b2221cd374e66732a09fb24b56ce" title="This macro creates a composite state.">RKH_CREATE_COMP_STATE()</a> and <a class="el" href="rkh_8h.html#a3567a7f91a5dc5759747dc8528357b44" title="This macro creates a basic state.">RKH_CREATE_BASIC_STATE()</a> macros. <b>RKH_SMA_EN_ENT_ARG_SMA</b> macro. </dd></dl>

<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l01140">1140</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab9e5faba972278beb83d7fd998774aa3"></a><!-- doxytag: member="rkhitl.h::RKHEXT_T" ref="ab9e5faba972278beb83d7fd998774aa3" args=")(const struct rkhsma_t *sma)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( * <a class="el" href="rkhitl_8h.html#ab9e5faba972278beb83d7fd998774aa3">RKHEXT_T</a>)(const struct rkhsma_t *sma)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Exit action. </p>
<p>The actions that are always execute when a state is exited should be exit actions. UML statecharts provide optional entry and exit actions, which are associated with states rather than transitions, as in a Moore automaton. An exit function takes the state machine pointer as argument. This argument is optional, thus it could be eliminated in compile-time by means of RKH_SMA_EN_EXT_ARG_SMA.</p>
<p>The RKH implementation preserves the transition sequence imposed by Harel's Statechart and UML. Specifically, the implemented transition sequence is as follows:</p>
<p>1. Execute exit actions of the source state. 2. Execute the transition actions. 3. Execute entry actions of the target state.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This callback is referenced from <a class="el" href="rkh_8h.html#acc24b2221cd374e66732a09fb24b56ce" title="This macro creates a composite state.">RKH_CREATE_COMP_STATE()</a> and <a class="el" href="rkh_8h.html#a3567a7f91a5dc5759747dc8528357b44" title="This macro creates a basic state.">RKH_CREATE_BASIC_STATE()</a> macros. </dd></dl>

<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l01182">1182</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3f1afca9ba9935082740bf026862729c"></a><!-- doxytag: member="rkhitl.h::RKHPPRO_T" ref="a3f1afca9ba9935082740bf026862729c" args=")(const struct rkhsma_t *sma, RKHEVT_T *pe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="rkhevt_8h.html#a8a78cec3a9dfc2336bd084c221e15e10">RKHE_T</a>( * <a class="el" href="rkhitl_8h.html#a3f1afca9ba9935082740bf026862729c">RKHPPRO_T</a>)(const struct rkhsma_t *sma, <a class="el" href="struct_r_k_h_e_v_t___t.html">RKHEVT_T</a> *pe)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Event preprocessor. </p>
<p>Before sending the arrived event to state machine, it can be previously processed using the event preprocessor function. The RKH framework provides optional event preprocessor action, which are associated with states rather than transitions, as in a Moore automaton. This action takes the state machine pointer and the event pointer as arguments. This argument is optional, thus it could be eliminated in compile-time by means of RKH_SMA_EN_PPRO_ARG_SMA.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This callback is referenced from <a class="el" href="rkh_8h.html#acc24b2221cd374e66732a09fb24b56ce" title="This macro creates a composite state.">RKH_CREATE_COMP_STATE()</a> and <a class="el" href="rkh_8h.html#a3567a7f91a5dc5759747dc8528357b44" title="This macro creates a basic state.">RKH_CREATE_BASIC_STATE()</a> macros. </dd></dl>

<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l01219">1219</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5b907a35e91da0cbe44d7ea879fdd001"></a><!-- doxytag: member="rkhitl.h::RKHACT_T" ref="a5b907a35e91da0cbe44d7ea879fdd001" args=")(const struct rkhsma_t *sma, RKHEVT_T *pe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="rkhitl_8h.html#a5b907a35e91da0cbe44d7ea879fdd001">RKHACT_T</a>)(const struct rkhsma_t *sma, <a class="el" href="struct_r_k_h_e_v_t___t.html">RKHEVT_T</a> *pe)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transition action. </p>
<p>Transition actions are small atomic behaviors executed at specified points in a state machine. This actions are assumed to take an insignificant amount of time to execute and are noninterruptible. UML statecharts are extended state machines with characteristics of both Mealy and Moore automata. In statecharts, actions generally depend on both the state of the system and the triggering event, as in a Mealy automaton. Additionally, UML statecharts provide optional entry and exit actions, which are associated with states rather than transitions, as in a Moore automaton. An action function takes the state machine pointer and the event pointer as arguments. These arguments are optional, thus they could be eliminated in compile-time by means of RKH_SMA_EN_ACT_ARG_EVT and <b>RKH_SMA_EN_ACT_ARG_SMA</b>.</p>
<p>The RKH implementation preserves the transition sequence imposed by Harel's Statechart and UML. Specifically, the implemented transition sequence is as follows:</p>
<p>1. Execute exit actions of the source state. 2. Execute the transition actions. 3. Execute entry actions of the target state.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This callback is referenced from <a class="el" href="rkh_8h.html#ab0fc2ccb4b73d57ea0c0f478353a00f6" title="This macro defines a regular state transition. The general syntax of an expression labelling a transi...">RKH_TRREG()</a> and <a class="el" href="rkh_8h.html#ac257d157f98ef172e5e8c8725a293bdf" title="This macro defines an internal state transition. Internal transitions are simple reactions to events ...">RKH_TRINT()</a>macro. </dd></dl>

<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l01261">1261</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9d6ea7aab791f836c1a28d2c8b13af3a"></a><!-- doxytag: member="rkhitl.h::RKHGUARD_T" ref="a9d6ea7aab791f836c1a28d2c8b13af3a" args=")(const struct rkhsma_t *sma, RKHEVT_T *pe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef HUInt(* <a class="el" href="rkhitl_8h.html#a9d6ea7aab791f836c1a28d2c8b13af3a">RKHGUARD_T</a>)(const struct rkhsma_t *sma, <a class="el" href="struct_r_k_h_e_v_t___t.html">RKHEVT_T</a> *pe)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Guard. </p>
<p>A guard is a boolean condition that returns a TRUE (RKH_GTRUE) or FALSE (RKH_GFALSE) value that controls whether or not a transition is taken following the receipt of a triggering event. A transition with a guard is only take if the triggering event occurs and the guard evaluates to TRUE. As long as the guard evaluated to FALSE, the triggering event would be discarded and the transition would not be taken. Each condition connector can have one special branch with a guard labeled rkh_else, which is taken if all the guards on the other branches are false. A guard function takes the state machine pointer and the event pointer as arguments. These arguments are optional, thus they could be eliminated in compile-time by means of <b>RKH_SMA_EN_GRD_ARG_EVT</b> and <b>RKH_SMA_EN_GRD_ARG_SMA</b>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This callback is referenced from <a class="el" href="rkh_8h.html#ad1ebb38b7398d7f4ec60ef3e0922d033" title="This macro defines a branch in the branch table.">RKH_BRANCH()</a> macro. </dd></dl>

<p>Definition at line <a class="el" href="rkhitl_8h_source.html#l01300">1300</a> of file <a class="el" href="rkhitl_8h_source.html">rkhitl.h</a>.</p>

</div>
</div>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed May 9 2012 13:05:35 for RKH by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
