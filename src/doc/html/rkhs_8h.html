<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RKH: rkhs.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">RKH
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">rkhs.h File Reference</div>  </div>
</div>
<div class="contents">

<p>Platform-independent interface to the RKS scheduler.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="rkhcfg_8h_source.html">rkhcfg.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="rkh_8h_source.html">rkh.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="rkhevt_8h_source.html">rkhevt.h</a>&quot;</code><br/>
</div>
<p><a href="rkhs_8h_source.html">Go to the source code of this file.</a></p>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Platform-independent interface to the RKS scheduler. </p>
<p><b>Run-to-completation execution model</b></p>
<p>Event occurrences are detected, dispatched, and then processed by the state machine, one at a time. The order of dequeuing is not defined, leaving open the possibility of modeling different priority-based schemes. The semantics of event occurrence processing is based on the run-to-completion assumption, interpreted as run-to-completion (RTC) processing. Run-to-completion processing means that an event occurrence can only be taken from the pool and dispatched if the processing of the previous current occurrence is fully completed.</p>
<p>The processing of a single event occurrence by a state machine is known as a run-to-completion step. An RTC step is the period of time in which events are accepted and acted upon. Processing an event always completes within a single model step, including exiting the source state, executing any associated actions, and entering the target state. Before commencing on a run-to-completion step, a state machine is in a stable state configuration with all entry/exit/internal activities (but not necessarily state (do) activities) completed. The same conditions apply after the run-to-completion step is completed. Thus, an event occurrence will never be processed while the state machine is in some intermediate and inconsistent situation. The run-to-completion step is the passage between two state configurations of the state machine. The run-to-completion assumption simplifies the transition function of the state machine, since concurrency conflicts are avoided during the processing of event, allowing the state machine to safely complete its run-to-completion step.</p>
<p>When an event occurrence is detected and dispatched, it may result in one or more transitions being enabled for firing. If no transition is enabled and the event (type) is not in the deferred event list of the current state configuration, the event occurrence is discarded and the run-to-completion step is completed. During a transition, a number of actions may be executed. If such an action is a synchronous operation invocation on an object executing a state machine, then the transition step is not completed until the invoked object completes its run-to-completion step.</p>
<p>The RKH implementation preserves the transition sequence imposed by Harel's Statechart and UML.</p>
<p>Run-to-completion may be implemented in various ways. The most common way to do that is by an event-loop running in its own thread, and that reads event occurrences from a pool.</p>
<p>In case of active objects or SMA <em>(State Machine Application)</em>, where each object has its own thread of execution, it is very important to clearly distinguish the notion of run-to-completion from the concept of thread pre-emption. Namely, run-to-completion event handling is performed by a thread that, in principle, can be pre-empted and its execution suspended in favor of another thread executing on the same processing node. (This is determined by the scheduling policy of the underlying thread environment, no assumptions are made about this policy.). When the suspended thread is assigned processor time again, it resumes its event processing from the point of pre-emption and, eventually, completes its event processing.</p>
<p><em> An active object is an object that, as a direct consequence of its creation, commences to execute its behavior, and does not cease until either the complete behavior is executed or the object is terminated by some external object. (This is sometimes referred to as "the object having its own thread of control"). An active object encapsulates a thread of control (event loop), a private event queue, and a state machine. So, Active object = thread of control + event queue + state machine.</em></p>
<p><b>Preemptive Kernel</b></p>
<p>In the most common and traditional implementations of the active object computing model, active objects map to threads of a traditional preemptive RTOS or OS. In this standard configuration the active object computing model can take full advantage of the underlying RTOS capabilities. In particular, if the kernel is preemptive, the active object system achieves exactly the same optimal task-level response as traditional tasks.</p>
<p>In this approach, RTC semantics of state machine execution do not mean that a state machine has to monopolize the CPU for the duration of the RTC step. A preemptive kernel can perform a context switch in the middle of the long RTC step to allow a higher-priority active object to run. As long as the active objects don't share resources, they can run concurrently and complete their RTC steps independently.</p>
<p>The <a class="el" href="rkhs_8h.html#fig15">Figure 15</a> shows the events flow in a interval of time to state machines A, B, and C, which have priority 2, 1 and 3, respectively. Note that, the lower the number the higher the priority. Moreover, the <a class="el" href="rkhs_8h.html#fig16">Figure 16</a> and <a class="el" href="rkhs_8h.html#fig17">Figure 17</a> are considered to illustrate how the preemptive kernel and cooperative kernel plays out in an active object system like <a class="el" href="rkhs_8h.html#fig15">Figure 15</a>. <br/>
 <br/>
</p>
<p><a class="anchor" id="fig15"></a> </p>
<div class="image">
<img src="rkhex.png" alt="rkhex.png"/>
<div class="caption">
Figure 15 - A multi-automata application</div></div>
<p> <br/>
 <a class="el" href="rkhs_8h.html#fig16">Figure 16</a> demonstrates how the active objects defined on the <a class="el" href="rkhs_8h.html#fig15">Figure 15</a> would be scheduled by a underlying preemptive kernel for executing event-driven system despicted in <a class="el" href="rkhs_8h.html#fig15">Figure 15</a>. <br/>
 <br/>
</p>
<p><a class="anchor" id="fig16"></a> </p>
<div class="image">
<img src="rkhpreem.png" alt="rkhpreem.png"/>
<div class="caption">
Figure 16 - RTC execution model on a fixed priority preemptive scheduling</div></div>
<p> <br/>
 The following explanation section illuminates the interesting points:<br/>
</p>
<ul>
<li>(0) When all event queues run out of events, neither of three active objects are able to run, the underlying kernel executes the idle task to give the application a chance to switch the MCU to a low-power sleep mode. </li>
<li>(1) The ISR executes and, among other things, posts event <b>A</b> to the active object <b>A</b>, which is now able to execute. It has a higher priority than the OS/RTOS idle task so is given processor time. </li>
<li>(2) The preemptive kernel switches context to the active object <b>A</b> to process the event to completation. </li>
<li>(3) While active object <b>A</b> is still executing, the ISR posts the event <b>E</b> to active object <b>C</b>, which is now able to execute, but as it has a lower priority than active object <b>A</b> it is not scheduled any processor time. </li>
<li>(4) Once again, while active object <b>A</b> is still executing, the ISR posts the event <b>D</b> to active object <b>A</b>, but it is already running the event is not processed, thus respecting the RTC execution model. </li>
<li>(5-6) The ISR executes and posts event <b>B</b> to the active object <b>B</b>, which is now able to execute. Now it is able to execute. As <b>B</b> has the higher priority <b>A</b> is suspended before it has completed processing the event, and <b>B</b> is scheduled processor time. </li>
<li>(7) Idem (3). </li>
<li>(8) The active object <b>B</b> has been completed the event processing. It cannot continue until another event has been received so suspends itself and the active object <b>A</b> is again the highest priority active object that is able to run so is scheduled processor time so the event <b>A</b> processing can be resumed. </li>
<li>(9) The active object <b>A</b> has been completed the event processing, and <b>A</b> is again the highest priority active object that is able to run so is scheduled processor time so the event <b>D</b> processing can be completed. </li>
<li>(10) Idem (5) and (6). </li>
<li>(11) Idem (8). </li>
<li>(12) Idem (9). </li>
<li>(13) Idem (11). </li>
<li>(14) Idem (0).</li>
</ul>
<p><b>Simple cooperative kernel</b></p>
<p>The active object computing model can also work with nonpreemptive kernels. In fact, one particular cooperative kernel matches the active object computing model exceptionally well and can be implemented in an absolutely portable manner.</p>
<p>The simple nonpreemptive native kernel executes one active object at a time in the infinite loop (similar to the "superloop"). The native kernel is engaged after each event is processed in the RTC fashion to choose the next highest-priority active object ready to process the next event. The native scheduler is cooperative, which means that all active objects cooperate to share a single CPU and implicitly yield to each other after every RTC step. The kernel is nonpreemptive, meaning that every active object must completely process an event before any other active object can start processing another event.</p>
<p>The ISRs can preempt the execution of active objects at any time, but due to the simplistic nature of the native kernel, every ISR returns to exactly the preemption point. If the ISR posts an event to any active object, the processing of this event won't start until the current RTC step completes. The maximum time an event for the highest-priority active object can be delayed this way is called the task-level response. With the nonpreemptive native kernel, the task-level response is equal to the longest RTC step of all active objects in the system. Note that the task-level response of the native kernel is still a lot better than the traditional "superloop" (a.k.a. main+ISRs) architecture.</p>
<p>The task-level response of the simple native kernel turns out to be adequate for surprisingly many applications because state machines by nature handle events quickly without a need to busy-wait for events. (A state machine simply runs to completion and becomes dormant until another event arrives.) Also note that often you can make the task-level response as fast as you need by breaking up longer RTC steps into shorter ones. [MS]</p>
<p><br/>
 <a class="el" href="rkhs_8h.html#fig16">Figure 17</a> demonstrates how the active objects defined on the <a class="el" href="rkhs_8h.html#fig15">Figure 15</a> would be scheduled by a simple, cooperative, and non-preemptive kernel for executing event-driven system despicted in <a class="el" href="rkhs_8h.html#fig15">Figure 15</a>. <br/>
 <br/>
</p>
<p><a class="anchor" id="fig17"></a> </p>
<div class="image">
<img src="rkhcoop.png" alt="rkhcoop.png"/>
<div class="caption">
Figure 17 - RTC execution model on a fixed priority cooperative scheduling</div></div>
<p> <br/>
 The following explanation section illuminates the interesting points:<br/>
</p>
<ul>
<li>(0) When all event queues run out of events, neither of three active objects are able to run, the underlying kernel executes the idle task to give the application a chance to switch the MCU to a low-power sleep mode. </li>
<li>(1) The ISR executes and, among other things, posts event <b>A</b> to the active object <b>A</b>, which is now able to execute. It has a higher priority than the OS/RTOS idle task so is given processor time. </li>
<li>(2) The preemptive kernel switches context to the active object <b>A</b> to process the event to completation. </li>
<li>(3,4,5) While active object <b>A</b> is still executing, the ISR posts the events <b>E</b>, <b>D</b> and <b>B</b> to active objects <b>C</b> and <b>B</b>, which are now able to execute, but as the underlying kernel is non-preemtive one active object <b>A</b> it is not scheduled any processor time until it has completed the current execution. </li>
<li>(6) The active object <b>A</b> has been completed the event processing. The active object <b>B</b> is the highest priority active object that is able to run so is scheduled processor time until is has completed the processing of event <b>B</b> in a RTC manner. </li>
<li>(7) Idem (3,4,5). </li>
<li>(8) Idem (6). </li>
<li>(9) Idem (3,4,5). </li>
<li>(10,11,12,13) Idem (6).</li>
</ul>
<p><b>Dealing with RTC model in a nonpreemtive manner</b></p>
<p>Here is the basic algorithm for interpreting the native kernel. The <a class="el" href="rkh_8h.html#a6b8f47b2f288dd0cf2c8b44dd062d509" title="RKH framework is started.">rkh_enter()</a> function implemented in <b>\source\rkhs.c</b> source file is self-explanatory.</p>
<div class="fragment"><pre class="fragment">    infinite loop
    {
        disable interrupts;
        <span class="keywordflow">if</span>( is_not_active_object_ready_to_run )
        {
            find the active <span class="keywordtype">object</span> with highest priority;
            enable interrupts;
            e = <span class="keyword">get</span> the <span class="keyword">event</span> from the active <span class="keywordtype">object</span><span class="stringliteral">&#39;s queue;</span>
<span class="stringliteral">            dispatch the &#39;</span>e<span class="stringliteral">&#39; event to the active object&#39;</span>s state machine;
        }
        <span class="keywordflow">else</span>
            execute the idle processing;
    }
</pre></div> 
<p>Definition in file <a class="el" href="rkhs_8h_source.html">rkhs.h</a>.</p>
</div></div>


<hr class="footer"/><address class="footer"><small>
Generated on Wed May 9 2012 13:05:35 for RKH by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
